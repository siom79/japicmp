<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JApiClass.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">japicmp</a> &gt; <a href="index.source.html" class="el_package">japicmp.model</a> &gt; <span class="el_source">JApiClass.java</span></div><h1>JApiClass.java</h1><pre class="source lang-java linenums">package japicmp.model;

import japicmp.cmp.JarArchiveComparator;
import japicmp.cmp.JarArchiveComparatorOptions;
import japicmp.exception.JApiCmpException;
import japicmp.util.Optional;
import japicmp.util.*;
import javassist.*;
import javassist.bytecode.AnnotationsAttribute;
import javassist.bytecode.ClassFile;

import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementWrapper;
import javax.xml.bind.annotation.XmlTransient;
import java.util.*;

import static japicmp.util.ModifierHelper.isSynthetic;

public class JApiClass implements JApiHasModifiers, JApiHasChangeStatus, JApiHasAccessModifier, JApiHasStaticModifier, JApiHasFinalModifier, JApiHasAbstractModifier,
	JApiCompatibility, JApiHasAnnotations, JApiJavaObjectSerializationCompatibility, JApiCanBeSynthetic, JApiHasGenericTemplates {
	private final JarArchiveComparator jarArchiveComparator;
	private final String fullyQualifiedName;
	private final JApiClassType classType;
	private final JarArchiveComparatorOptions options;
	private final Optional&lt;CtClass&gt; oldClass;
	private final Optional&lt;CtClass&gt; newClass;
	private final JApiChangeStatus changeStatus;
	private final JApiSuperclass superclass;
<span class="fc" id="L30">	private final List&lt;JApiImplementedInterface&gt; interfaces = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L31">	private final List&lt;JApiField&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L32">	private final List&lt;JApiConstructor&gt; constructors = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L33">	private final List&lt;JApiMethod&gt; methods = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L34">	private final List&lt;JApiAnnotation&gt; annotations = new ArrayList&lt;&gt;();</span>
	private final JApiModifier&lt;AccessModifier&gt; accessModifier;
	private final JApiModifier&lt;FinalModifier&gt; finalModifier;
	private final JApiModifier&lt;StaticModifier&gt; staticModifier;
	private final JApiModifier&lt;AbstractModifier&gt; abstractModifier;
	private final JApiModifier&lt;SyntheticModifier&gt; syntheticModifier;
	private final JApiAttribute&lt;SyntheticAttribute&gt; syntheticAttribute;
<span class="fc" id="L41">	private final List&lt;JApiCompatibilityChange&gt; compatibilityChanges = new ArrayList&lt;&gt;();</span>
	private final JApiSerialVersionUid jApiSerialVersionUid;
	private final JApiClassFileFormatVersion classFileFormatVersion;
<span class="fc" id="L44">	private boolean changeCausedByClassElement = false;</span>
<span class="fc" id="L45">	private JApiJavaObjectSerializationChangeStatus jApiJavaObjectSerializationChangeStatus = JApiJavaObjectSerializationChangeStatus.NOT_SERIALIZABLE;</span>
<span class="fc" id="L46">	private List&lt;JApiGenericTemplate&gt; genericTemplates = new ArrayList&lt;&gt;();</span>

	public JApiClass(JarArchiveComparator jarArchiveComparator, String fullyQualifiedName, Optional&lt;CtClass&gt; oldClass,
<span class="fc" id="L49">					 Optional&lt;CtClass&gt; newClass, JApiChangeStatus changeStatus, JApiClassType classType) {</span>
<span class="fc" id="L50">		this.jarArchiveComparator = jarArchiveComparator;</span>
<span class="fc" id="L51">		this.options = this.jarArchiveComparator.getJarArchiveComparatorOptions();</span>
<span class="fc" id="L52">		this.fullyQualifiedName = fullyQualifiedName;</span>
<span class="fc" id="L53">		this.newClass = newClass;</span>
<span class="fc" id="L54">		this.oldClass = oldClass;</span>
<span class="fc" id="L55">		this.classType = classType;</span>
<span class="fc" id="L56">		this.superclass = extractSuperclass(oldClass, newClass);</span>
<span class="fc" id="L57">		computeGenericTemplateChanges(oldClass, newClass);</span>
<span class="fc" id="L58">		computeMethodChanges(this, oldClass, newClass);</span>
<span class="fc" id="L59">		computeInterfaceChanges(this.interfaces, oldClass, newClass);</span>
<span class="fc" id="L60">		computeFieldChanges(this.fields, oldClass, newClass);</span>
<span class="fc" id="L61">		computeAnnotationChanges(this.annotations, oldClass, newClass);</span>
<span class="fc" id="L62">		this.accessModifier = extractAccessModifier(oldClass, newClass);</span>
<span class="fc" id="L63">		this.finalModifier = extractFinalModifier(oldClass, newClass);</span>
<span class="fc" id="L64">		this.staticModifier = extractStaticModifier(oldClass, newClass);</span>
<span class="fc" id="L65">		this.abstractModifier = extractAbstractModifier(oldClass, newClass);</span>
<span class="fc" id="L66">		this.syntheticModifier = extractSyntheticModifier(oldClass, newClass);</span>
<span class="fc" id="L67">		this.syntheticAttribute = extractSyntheticAttribute(oldClass, newClass);</span>
<span class="fc" id="L68">		this.jApiSerialVersionUid = JavaObjectSerializationCompatibility.extractSerialVersionUid(options, jarArchiveComparator, oldClass, newClass);</span>
<span class="fc" id="L69">		this.classFileFormatVersion = extractClassFileFormatVersion(oldClass, newClass);</span>
<span class="fc" id="L70">		this.changeStatus = evaluateChangeStatus(changeStatus);</span>
<span class="fc" id="L71">	}</span>

	private void computeGenericTemplateChanges(Optional&lt;CtClass&gt; oldClass, Optional&lt;CtClass&gt; newClass) {
<span class="fc" id="L74">		this.genericTemplates = GenericTemplateHelper.computeGenericTemplateChanges(new GenericTemplateHelper.SignatureParserCallback() {</span>
			@Override
			public boolean isOldAndNewPresent() {
<span class="fc bfc" id="L77" title="All 4 branches covered.">				return oldClass.isPresent() &amp;&amp; newClass.isPresent();</span>
			}

			@Override
			public boolean isOldPresent() {
<span class="fc" id="L82">				return oldClass.isPresent();</span>
			}

			@Override
			public boolean isNewPresent() {
<span class="fc" id="L87">				return newClass.isPresent();</span>
			}

			@Override
			public SignatureParser oldSignatureParser() {
<span class="fc" id="L92">				SignatureParser signatureParser = new SignatureParser();</span>
<span class="fc" id="L93">				signatureParser.parseTemplatesOfClass(oldClass.get());</span>
<span class="fc" id="L94">				return signatureParser;</span>
			}

			@Override
			public SignatureParser newSignatureParser() {
<span class="fc" id="L99">				SignatureParser signatureParser = new SignatureParser();</span>
<span class="fc" id="L100">				signatureParser.parseTemplatesOfClass(newClass.get());</span>
<span class="fc" id="L101">				return signatureParser;</span>
			}
		});
<span class="fc" id="L104">	}</span>

	private JApiClassFileFormatVersion extractClassFileFormatVersion(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc bfc" id="L107" title="All 4 branches covered.">		if (oldClassOptional.isPresent() &amp;&amp; newClassOptional.isPresent()) {</span>
<span class="fc" id="L108">			CtClass oldClass = oldClassOptional.get();</span>
<span class="fc" id="L109">			CtClass newClass = newClassOptional.get();</span>
<span class="fc" id="L110">			ClassFile classFileOld = oldClass.getClassFile();</span>
<span class="fc" id="L111">			ClassFile classFileNew = newClass.getClassFile();</span>
<span class="fc" id="L112">			return new JApiClassFileFormatVersion(classFileOld.getMajorVersion(), classFileOld.getMinorVersion(), classFileNew.getMajorVersion(), classFileNew.getMinorVersion());</span>
		} else {
<span class="fc bfc" id="L114" title="All 2 branches covered.">			if (oldClassOptional.isPresent()) {</span>
<span class="fc" id="L115">				CtClass oldClass = oldClassOptional.get();</span>
<span class="fc" id="L116">				ClassFile classFileOld = oldClass.getClassFile();</span>
<span class="fc" id="L117">				return new JApiClassFileFormatVersion(classFileOld.getMajorVersion(), classFileOld.getMinorVersion(), -1, -1);</span>
			}
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">			if (newClassOptional.isPresent()) {</span>
<span class="fc" id="L120">				CtClass newClass = newClassOptional.get();</span>
<span class="fc" id="L121">				ClassFile classFileNew = newClass.getClassFile();</span>
<span class="fc" id="L122">				return new JApiClassFileFormatVersion(-1, -1, classFileNew.getMajorVersion(), classFileNew.getMinorVersion());</span>
			}
<span class="nc" id="L124">			return new JApiClassFileFormatVersion(-1, -1, -1, -1);</span>
		}
	}

	private void computeAnnotationChanges(List&lt;JApiAnnotation&gt; annotations, Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L129">		AnnotationHelper.computeAnnotationChanges(annotations, oldClassOptional, newClassOptional, options, new AnnotationHelper.AnnotationsAttributeCallback&lt;CtClass&gt;() {</span>
			@Override
			public AnnotationsAttribute getAnnotationsAttribute(CtClass ctClass) {
<span class="fc" id="L132">				return (AnnotationsAttribute) ctClass.getClassFile().getAttribute(AnnotationsAttribute.visibleTag);</span>
			}
		});
<span class="fc" id="L135">	}</span>

	private JApiAttribute&lt;SyntheticAttribute&gt; extractSyntheticAttribute(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L138">		JApiAttribute&lt;SyntheticAttribute&gt; jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.UNCHANGED, Optional.of(SyntheticAttribute.SYNTHETIC), Optional.of(SyntheticAttribute.SYNTHETIC));</span>
<span class="fc bfc" id="L139" title="All 4 branches covered.">		if (oldClassOptional.isPresent() &amp;&amp; newClassOptional.isPresent()) {</span>
<span class="fc" id="L140">			CtClass oldClass = oldClassOptional.get();</span>
<span class="fc" id="L141">			CtClass newClass = newClassOptional.get();</span>
<span class="fc" id="L142">			byte[] attributeOldClass = oldClass.getAttribute(Constants.JAVA_CONSTPOOL_ATTRIBUTE_SYNTHETIC);</span>
<span class="fc" id="L143">			byte[] attributeNewClass = newClass.getAttribute(Constants.JAVA_CONSTPOOL_ATTRIBUTE_SYNTHETIC);</span>
<span class="pc bpc" id="L144" title="3 of 4 branches missed.">			if (attributeOldClass != null &amp;&amp; attributeNewClass != null) {</span>
<span class="nc" id="L145">				jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.UNCHANGED, Optional.of(SyntheticAttribute.SYNTHETIC), Optional.of(SyntheticAttribute.SYNTHETIC));</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">			} else if (attributeOldClass != null) {</span>
<span class="nc" id="L147">				jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.MODIFIED, Optional.of(SyntheticAttribute.SYNTHETIC), Optional.of(SyntheticAttribute.NON_SYNTHETIC));</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">			} else if (attributeNewClass != null) {</span>
<span class="nc" id="L149">				jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.MODIFIED, Optional.of(SyntheticAttribute.NON_SYNTHETIC), Optional.of(SyntheticAttribute.SYNTHETIC));</span>
			} else {
<span class="fc" id="L151">				jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.UNCHANGED, Optional.of(SyntheticAttribute.NON_SYNTHETIC), Optional.of(SyntheticAttribute.NON_SYNTHETIC));</span>
			}
<span class="fc" id="L153">		} else {</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">			if (oldClassOptional.isPresent()) {</span>
<span class="fc" id="L155">				CtClass ctClass = oldClassOptional.get();</span>
<span class="fc" id="L156">				byte[] attribute = ctClass.getAttribute(Constants.JAVA_CONSTPOOL_ATTRIBUTE_SYNTHETIC);</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">				if (attribute != null) {</span>
<span class="nc" id="L158">					jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.REMOVED, Optional.of(SyntheticAttribute.SYNTHETIC), Optional.&lt;SyntheticAttribute&gt;absent());</span>
				} else {
<span class="fc" id="L160">					jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.REMOVED, Optional.of(SyntheticAttribute.NON_SYNTHETIC), Optional.&lt;SyntheticAttribute&gt;absent());</span>
				}
			}
<span class="fc bfc" id="L163" title="All 2 branches covered.">			if (newClassOptional.isPresent()) {</span>
<span class="fc" id="L164">				CtClass ctClass = newClassOptional.get();</span>
<span class="fc" id="L165">				byte[] attribute = ctClass.getAttribute(Constants.JAVA_CONSTPOOL_ATTRIBUTE_SYNTHETIC);</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">				if (attribute != null) {</span>
<span class="nc" id="L167">					jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.NEW, Optional.&lt;SyntheticAttribute&gt;absent(), Optional.of(SyntheticAttribute.SYNTHETIC));</span>
				} else {
<span class="fc" id="L169">					jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.NEW, Optional.&lt;SyntheticAttribute&gt;absent(), Optional.of(SyntheticAttribute.NON_SYNTHETIC));</span>
				}
			}
		}
<span class="fc" id="L173">		return jApiAttribute;</span>
	}

	private void computeFieldChanges(List&lt;JApiField&gt; fields, Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc bfc" id="L177" title="All 4 branches covered.">		if (oldClassOptional.isPresent() &amp;&amp; newClassOptional.isPresent()) {</span>
<span class="fc" id="L178">			CtClass oldClass = oldClassOptional.get();</span>
<span class="fc" id="L179">			CtClass newClass = newClassOptional.get();</span>
<span class="fc" id="L180">			Map&lt;String, CtField&gt; oldFieldsMap = buildFieldMap(oldClass);</span>
<span class="fc" id="L181">			Map&lt;String, CtField&gt; newFieldsMap = buildFieldMap(newClass);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">			for (CtField oldField : oldFieldsMap.values()) {</span>
<span class="fc" id="L183">				String oldFieldName = oldField.getName();</span>
<span class="fc" id="L184">				CtField newField = newFieldsMap.get(oldFieldName);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">				if (newField != null) {</span>
<span class="fc" id="L186">					JApiField jApiField = new JApiField(this, JApiChangeStatus.UNCHANGED, Optional.of(oldField), Optional.of(newField), options);</span>
<span class="fc" id="L187">					enhanceGenericTypeToField(oldField, jApiField.getOldGenericTypes());</span>
<span class="fc" id="L188">					enhanceGenericTypeToField(newField, jApiField.getNewGenericTypes());</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">					if (includeField(jApiField)) {</span>
<span class="fc" id="L190">						fields.add(jApiField);</span>
					}
<span class="fc" id="L192">				} else {</span>
<span class="fc" id="L193">					JApiField jApiField = new JApiField(this, JApiChangeStatus.REMOVED, Optional.of(oldField), Optional.&lt;CtField&gt;absent(), options);</span>
<span class="fc" id="L194">					enhanceGenericTypeToField(oldField, jApiField.getOldGenericTypes());</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">					if (includeField(jApiField)) {</span>
<span class="fc" id="L196">						fields.add(jApiField);</span>
					}
				}
<span class="fc" id="L199">			}</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">			for (CtField newField : newFieldsMap.values()) {</span>
<span class="fc" id="L201">				CtField oldField = oldFieldsMap.get(newField.getName());</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">				if (oldField == null) {</span>
<span class="fc" id="L203">					JApiField jApiField = new JApiField(this, JApiChangeStatus.NEW, Optional.&lt;CtField&gt;absent(), Optional.of(newField), options);</span>
<span class="fc" id="L204">					enhanceGenericTypeToField(newField, jApiField.getNewGenericTypes());</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">					if (includeField(jApiField)) {</span>
<span class="fc" id="L206">						fields.add(jApiField);</span>
					}
				}
<span class="fc" id="L209">			}</span>
<span class="fc" id="L210">		} else {</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">			if (oldClassOptional.isPresent()) {</span>
<span class="fc" id="L212">				Map&lt;String, CtField&gt; fieldMap = buildFieldMap(oldClassOptional.get());</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">				for (CtField field : fieldMap.values()) {</span>
<span class="nc" id="L214">					JApiField jApiField = new JApiField(this, JApiChangeStatus.REMOVED, Optional.of(field), Optional.&lt;CtField&gt;absent(), options);</span>
<span class="nc" id="L215">					enhanceGenericTypeToField(field, jApiField.getOldGenericTypes());</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">					if (includeField(jApiField)) {</span>
<span class="nc" id="L217">						fields.add(jApiField);</span>
					}
<span class="nc" id="L219">				}</span>
			}
<span class="fc bfc" id="L221" title="All 2 branches covered.">			if (newClassOptional.isPresent()) {</span>
<span class="fc" id="L222">				Map&lt;String, CtField&gt; fieldMap = buildFieldMap(newClassOptional.get());</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">				for (CtField field : fieldMap.values()) {</span>
<span class="fc" id="L224">					JApiField jApiField = new JApiField(this, JApiChangeStatus.NEW, Optional.&lt;CtField&gt;absent(), Optional.of(field), options);</span>
<span class="fc" id="L225">					enhanceGenericTypeToField(field, jApiField.getNewGenericTypes());</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">					if (includeField(jApiField)) {</span>
<span class="fc" id="L227">						fields.add(jApiField);</span>
					}
<span class="fc" id="L229">				}</span>
			}
		}
<span class="fc" id="L232">	}</span>

	private void enhanceGenericTypeToField(CtField field, List&lt;JApiGenericType&gt; genericTypes) {
<span class="fc bfc" id="L235" title="All 2 branches covered.">		if (field.getGenericSignature() != null) {</span>
<span class="fc" id="L236">			SignatureParser signatureParser = new SignatureParser();</span>
<span class="fc" id="L237">			List&lt;SignatureParser.ParsedParameter&gt; parsedParameters = signatureParser.parseTypes(field.getGenericSignature());</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">			if (!parsedParameters.isEmpty()) {</span>
<span class="fc" id="L239">				SignatureParser.ParsedParameter parsedParameter = parsedParameters.get(0);</span>
<span class="fc" id="L240">				SignatureParser.copyGenericParameters(parsedParameter, genericTypes);</span>
			}
		}
<span class="fc" id="L243">	}</span>

	private boolean includeField(JApiField jApiField) {
<span class="fc" id="L246">		return ModifierHelper.matchesModifierLevel(jApiField, options.getAccessModifier());</span>
	}

	private Map&lt;String, CtField&gt; buildFieldMap(CtClass ctClass) {
<span class="fc" id="L250">		Map&lt;String, CtField&gt; fieldMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L251">		CtField[] declaredFields = ctClass.getDeclaredFields();</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">		for (CtField field : declaredFields) {</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">			if (options.getFilters().includeField(field)) {</span>
<span class="fc" id="L254">				String name = field.getName();</span>
<span class="fc" id="L255">				fieldMap.put(name, field);</span>
			}
		}
<span class="fc" id="L258">		return fieldMap;</span>
	}

	private JApiSuperclass extractSuperclass(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L262">		JApiSuperclass retVal = new JApiSuperclass(this, Optional.&lt;CtClass&gt;absent(), Optional.&lt;CtClass&gt;absent(), JApiChangeStatus.UNCHANGED, jarArchiveComparator);</span>
<span class="fc bfc" id="L263" title="All 4 branches covered.">		if (oldClassOptional.isPresent() &amp;&amp; newClassOptional.isPresent()) {</span>
<span class="fc" id="L264">			CtClass oldClass = oldClassOptional.get();</span>
<span class="fc" id="L265">			CtClass newClass = newClassOptional.get();</span>
<span class="fc" id="L266">			Optional&lt;CtClass&gt; superclassOldOptional = getSuperclass(oldClass);</span>
<span class="fc" id="L267">			Optional&lt;CtClass&gt; superclassNewOptional = getSuperclass(newClass);</span>
<span class="pc bpc" id="L268" title="1 of 4 branches missed.">			if (superclassOldOptional.isPresent() &amp;&amp; superclassNewOptional.isPresent()) {</span>
<span class="fc" id="L269">				String nameOld = superclassOldOptional.get().getName();</span>
<span class="fc" id="L270">				String nameNew = superclassNewOptional.get().getName();</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">				retVal = new JApiSuperclass(this, superclassOldOptional, superclassNewOptional, nameOld.equals(nameNew) ? JApiChangeStatus.UNCHANGED : JApiChangeStatus.MODIFIED, jarArchiveComparator);</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">			} else if (superclassOldOptional.isPresent()) {</span>
<span class="nc" id="L273">				retVal = new JApiSuperclass(this, superclassOldOptional, superclassNewOptional, JApiChangeStatus.REMOVED, jarArchiveComparator);</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">			} else if (superclassNewOptional.isPresent()) {</span>
<span class="nc" id="L275">				retVal = new JApiSuperclass(this, superclassOldOptional, superclassNewOptional, JApiChangeStatus.NEW, jarArchiveComparator);</span>
			} else {
<span class="fc" id="L277">				retVal = new JApiSuperclass(this, superclassOldOptional, superclassNewOptional, JApiChangeStatus.UNCHANGED, jarArchiveComparator);</span>
			}
<span class="fc" id="L279">		} else {</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">			if (oldClassOptional.isPresent()) {</span>
<span class="fc" id="L281">				Optional&lt;CtClass&gt; superclassOldOptional = getSuperclass(oldClassOptional.get());</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">				if (superclassOldOptional.isPresent()) {</span>
<span class="fc" id="L283">					retVal = new JApiSuperclass(this, superclassOldOptional, Optional.&lt;CtClass&gt;absent(), JApiChangeStatus.REMOVED, jarArchiveComparator);</span>
				} else {
<span class="nc" id="L285">					retVal = new JApiSuperclass(this, Optional.&lt;CtClass&gt;absent(), Optional.&lt;CtClass&gt;absent(), JApiChangeStatus.UNCHANGED, jarArchiveComparator);</span>
				}
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">			} else if (newClassOptional.isPresent()) {</span>
<span class="fc" id="L288">				Optional&lt;CtClass&gt; superclassNewOptional = getSuperclass(newClassOptional.get());</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">				if (superclassNewOptional.isPresent()) {</span>
<span class="fc" id="L290">					retVal = new JApiSuperclass(this, Optional.&lt;CtClass&gt;absent(), superclassNewOptional, JApiChangeStatus.NEW, jarArchiveComparator);</span>
				} else {
<span class="fc" id="L292">					retVal = new JApiSuperclass(this, Optional.&lt;CtClass&gt;absent(), Optional.&lt;CtClass&gt;absent(), JApiChangeStatus.UNCHANGED, jarArchiveComparator);</span>
				}
			}
		}
<span class="fc" id="L296">		return retVal;</span>
	}

	private Optional&lt;CtClass&gt; getSuperclass(CtClass ctClass) {
		try {
<span class="fc" id="L301">			CtClass superClass = ctClass.getSuperclass();</span>
<span class="fc" id="L302">			return Optional.fromNullable(superClass);</span>
<span class="fc" id="L303">		} catch (NotFoundException e) {</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">			if (options.getIgnoreMissingClasses().ignoreClass(e.getMessage())) {</span>
<span class="fc" id="L305">				return Optional.absent();</span>
			} else {
<span class="fc" id="L307">				throw JApiCmpException.forClassLoading(e, e.getMessage(), jarArchiveComparator);</span>
			}
		}
	}

	private void computeInterfaceChanges(List&lt;JApiImplementedInterface&gt; interfacesArg, Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc bfc" id="L313" title="All 4 branches covered.">		if (oldClassOptional.isPresent() &amp;&amp; newClassOptional.isPresent()) {</span>
<span class="fc" id="L314">			CtClass oldClass = oldClassOptional.get();</span>
<span class="fc" id="L315">			CtClass newClass = newClassOptional.get();</span>
<span class="fc" id="L316">			Map&lt;String, CtClass&gt; interfaceMapOldClass = buildInterfaceMap(oldClass, JarArchiveComparator.ArchiveType.OLD);</span>
<span class="fc" id="L317">			Map&lt;String, CtClass&gt; interfaceMapNewClass = buildInterfaceMap(newClass, JarArchiveComparator.ArchiveType.NEW);</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">			for (CtClass oldInterface : interfaceMapOldClass.values()) {</span>
<span class="fc" id="L319">				CtClass ctClassFound = interfaceMapNewClass.get(oldInterface.getName());</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">				if (ctClassFound != null) {</span>
<span class="fc" id="L321">					JApiImplementedInterface jApiClass = new JApiImplementedInterface(oldInterface, oldInterface.getName(), JApiChangeStatus.UNCHANGED);</span>
<span class="fc" id="L322">					interfacesArg.add(jApiClass);</span>
<span class="fc" id="L323">				} else {</span>
<span class="fc" id="L324">					JApiImplementedInterface jApiClass = new JApiImplementedInterface(oldInterface, oldInterface.getName(), JApiChangeStatus.REMOVED);</span>
<span class="fc" id="L325">					interfacesArg.add(jApiClass);</span>
				}
<span class="fc" id="L327">			}</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">			for (CtClass newInterface : interfaceMapNewClass.values()) {</span>
<span class="fc" id="L329">				CtClass ctClassFound = interfaceMapOldClass.get(newInterface.getName());</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">				if (ctClassFound == null) {</span>
<span class="fc" id="L331">					JApiImplementedInterface jApiClass = new JApiImplementedInterface(newInterface, newInterface.getName(), JApiChangeStatus.NEW);</span>
<span class="fc" id="L332">					interfacesArg.add(jApiClass);</span>
				}
<span class="fc" id="L334">			}</span>
<span class="fc" id="L335">		} else {</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">			if (oldClassOptional.isPresent()) {</span>
<span class="fc" id="L337">				Map&lt;String, CtClass&gt; interfaceMap = buildInterfaceMap(oldClassOptional.get(), JarArchiveComparator.ArchiveType.OLD);</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">				for (CtClass ctClass : interfaceMap.values()) {</span>
<span class="fc" id="L339">					JApiImplementedInterface jApiClass = new JApiImplementedInterface(ctClass, ctClass.getName(), JApiChangeStatus.REMOVED);</span>
<span class="fc" id="L340">					interfacesArg.add(jApiClass);</span>
<span class="fc" id="L341">				}</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">			} else if (newClassOptional.isPresent()) {</span>
<span class="fc" id="L343">				Map&lt;String, CtClass&gt; interfaceMap = buildInterfaceMap(newClassOptional.get(), JarArchiveComparator.ArchiveType.NEW);</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">				for (CtClass ctClass : interfaceMap.values()) {</span>
<span class="fc" id="L345">					JApiImplementedInterface jApiClass = new JApiImplementedInterface(ctClass, ctClass.getName(), JApiChangeStatus.NEW);</span>
<span class="fc" id="L346">					interfacesArg.add(jApiClass);</span>
<span class="fc" id="L347">				}</span>
			}
		}
<span class="fc" id="L350">	}</span>

	private Map&lt;String, CtClass&gt; buildInterfaceMap(CtClass ctClass, JarArchiveComparator.ArchiveType archiveType) {
<span class="fc" id="L353">		Map&lt;String, CtClass&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L354">		buildInterfaceMap(ctClass, archiveType, map);</span>
<span class="fc" id="L355">		return map;</span>
	}

	private void buildInterfaceMap(CtClass ctClass, JarArchiveComparator.ArchiveType archiveType, Map&lt;String, CtClass&gt; map) {
		try {
<span class="fc" id="L360">			CtClass[] interfaces = ctClass.getInterfaces();</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">			for (CtClass ctInterface : interfaces) {</span>
<span class="fc" id="L362">				map.put(ctInterface.getName(), ctInterface);</span>
<span class="fc" id="L363">				buildInterfaceMap(archiveType, map, ctInterface);</span>
			}
<span class="fc" id="L365">			Optional&lt;CtClass&gt; superClassOptional = getSuperclass(ctClass);</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">			if (superClassOptional.isPresent()) {</span>
<span class="fc" id="L367">				buildInterfaceMap(superClassOptional.get(), archiveType, map);</span>
			}
<span class="nc" id="L369">		} catch (NotFoundException e) {</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">			if (!options.getIgnoreMissingClasses().ignoreClass(e.getMessage())) {</span>
<span class="nc" id="L371">				throw JApiCmpException.forClassLoading(e, &quot;Class not found: &quot; + e.getMessage(), jarArchiveComparator);</span>
			}
<span class="fc" id="L373">		}</span>
<span class="fc" id="L374">	}</span>

	private void buildInterfaceMap(JarArchiveComparator.ArchiveType archiveType, Map&lt;String, CtClass&gt; map, CtClass ctInterface) throws NotFoundException {
<span class="fc" id="L377">		Optional&lt;CtClass&gt; loadedInterfaceOptional = this.jarArchiveComparator.loadClass(archiveType, ctInterface.getName());</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">		if (loadedInterfaceOptional.isPresent()) {</span>
<span class="fc" id="L379">			CtClass loadedInterface = loadedInterfaceOptional.get();</span>
<span class="fc" id="L380">			CtClass[] loadedInterfaceInterfaces = loadedInterface.getInterfaces();</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">			for (CtClass additionalInterface : loadedInterfaceInterfaces) {</span>
<span class="fc" id="L382">				map.put(additionalInterface.getName(), additionalInterface);</span>
<span class="fc" id="L383">				buildInterfaceMap(archiveType, map, additionalInterface);</span>
			}
		}
<span class="fc" id="L386">	}</span>

	private void computeMethodChanges(JApiClass jApiClass, Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L389">		Map&lt;String, List&lt;CtMethod&gt;&gt; oldMethodsMap = createMethodMap(oldClassOptional);</span>
<span class="fc" id="L390">		Map&lt;String, List&lt;CtMethod&gt;&gt; newMethodsMap = createMethodMap(newClassOptional);</span>
<span class="fc" id="L391">		sortMethodsIntoLists(jApiClass, oldMethodsMap, newMethodsMap);</span>
<span class="fc" id="L392">		Map&lt;String, CtConstructor&gt; oldConstructorsMap = createConstructorMap(oldClassOptional);</span>
<span class="fc" id="L393">		Map&lt;String, CtConstructor&gt; newConstructorsMap = createConstructorMap(newClassOptional);</span>
<span class="fc" id="L394">		sortConstructorsIntoLists(jApiClass, oldConstructorsMap, newConstructorsMap);</span>
<span class="fc" id="L395">	}</span>

	private void sortMethodsIntoLists(JApiClass jApiClass, Map&lt;String, List&lt;CtMethod&gt;&gt; oldMethodsMap, Map&lt;String, List&lt;CtMethod&gt;&gt; newMethodsMap) {
<span class="fc" id="L398">		SignatureParser methodDescriptorParser = new SignatureParser();</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">		for (String methodName : oldMethodsMap.keySet()) {</span>
<span class="fc" id="L400">			List&lt;CtMethod&gt; oldMethodsWithSameName = oldMethodsMap.get(methodName);</span>
<span class="fc" id="L401">			Iterator&lt;CtMethod&gt; oldMethodsWithSameNameIterator = oldMethodsWithSameName.iterator();</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">			while (oldMethodsWithSameNameIterator.hasNext()) {</span>
<span class="fc" id="L403">				CtMethod oldMethod = oldMethodsWithSameNameIterator.next();</span>
<span class="fc" id="L404">				methodDescriptorParser.parse(oldMethod);</span>
<span class="fc" id="L405">				List&lt;CtMethod&gt; newMethodsWithSameName = newMethodsMap.get(methodName);</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">				if (newMethodsWithSameName == null) {</span>
<span class="fc" id="L407">					JApiMethod jApiMethod = new JApiMethod(jApiClass, oldMethod.getName(), JApiChangeStatus.REMOVED, Optional.of(oldMethod), Optional.&lt;CtMethod&gt;absent(), jarArchiveComparator);</span>
<span class="fc" id="L408">					addParametersToMethod(methodDescriptorParser, jApiMethod);</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">					if (includeMethod(jApiMethod)) {</span>
<span class="fc" id="L410">						methods.add(jApiMethod);</span>
					}
<span class="fc" id="L412">				} else {</span>
<span class="fc" id="L413">					Optional&lt;CtMethod&gt; matchingMethodOptional = findMatchingMethod(oldMethod, newMethodsWithSameName);</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">					if (matchingMethodOptional.isPresent()) {</span>
<span class="fc" id="L415">						CtMethod matchingMethod = matchingMethodOptional.get();</span>
<span class="fc" id="L416">						JApiMethod jApiMethod = new JApiMethod(jApiClass, oldMethod.getName(), JApiChangeStatus.UNCHANGED, Optional.of(oldMethod), Optional.of(matchingMethod), jarArchiveComparator);</span>
<span class="fc" id="L417">						addParametersToMethod(methodDescriptorParser, jApiMethod);</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">						if (includeMethod(jApiMethod)) {</span>
<span class="fc" id="L419">							methods.add(jApiMethod);</span>
						}
<span class="fc" id="L421">						oldMethodsWithSameNameIterator.remove();</span>
<span class="fc" id="L422">						newMethodsWithSameName.remove(matchingMethod);</span>
<span class="fc" id="L423">					} else {</span>
<span class="fc" id="L424">						JApiMethod jApiMethod = new JApiMethod(jApiClass, oldMethod.getName(), JApiChangeStatus.REMOVED, Optional.of(oldMethod), Optional.&lt;CtMethod&gt;absent(), jarArchiveComparator);</span>
<span class="fc" id="L425">						addParametersToMethod(methodDescriptorParser, jApiMethod);</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">						if (includeMethod(jApiMethod)) {</span>
<span class="fc" id="L427">							methods.add(jApiMethod);</span>
						}
					}
				}
<span class="fc" id="L431">			}</span>
<span class="fc" id="L432">		}</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">		for (String methodName : newMethodsMap.keySet()) {</span>
<span class="fc" id="L434">			List&lt;CtMethod&gt; ctMethods = newMethodsMap.get(methodName);</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">			for (CtMethod ctMethod : ctMethods) {</span>
<span class="fc" id="L436">				methodDescriptorParser.parse(ctMethod);</span>
<span class="fc" id="L437">				List&lt;CtMethod&gt; methodsWithSameName = oldMethodsMap.get(ctMethod.getName());</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">				if (methodsWithSameName == null) {</span>
<span class="fc" id="L439">					JApiMethod jApiMethod = new JApiMethod(jApiClass, ctMethod.getName(), JApiChangeStatus.NEW, Optional.&lt;CtMethod&gt;absent(), Optional.of(ctMethod), jarArchiveComparator);</span>
<span class="fc" id="L440">					addParametersToMethod(methodDescriptorParser, jApiMethod);</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">					if (includeMethod(jApiMethod)) {</span>
<span class="fc" id="L442">						methods.add(jApiMethod);</span>
					}
<span class="fc" id="L444">				} else {</span>
<span class="fc" id="L445">					Optional&lt;CtMethod&gt; matchingMethodOptional = findMatchingMethod(ctMethod, methodsWithSameName);</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">					if (matchingMethodOptional.isPresent()) {</span>
<span class="nc" id="L447">						CtMethod matchingMethod = matchingMethodOptional.get();</span>
<span class="nc" id="L448">						JApiMethod jApiMethod = new JApiMethod(jApiClass, ctMethod.getName(), JApiChangeStatus.UNCHANGED, Optional.of(ctMethod), Optional.of(matchingMethod), jarArchiveComparator);</span>
<span class="nc" id="L449">						addParametersToMethod(methodDescriptorParser, jApiMethod);</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">						if (includeMethod(jApiMethod)) {</span>
<span class="nc" id="L451">							methods.add(jApiMethod);</span>
						}
<span class="nc" id="L453">					} else {</span>
<span class="fc" id="L454">						JApiMethod jApiMethod = new JApiMethod(jApiClass, ctMethod.getName(), JApiChangeStatus.NEW, Optional.&lt;CtMethod&gt;absent(), Optional.of(ctMethod), jarArchiveComparator);</span>
<span class="fc" id="L455">						addParametersToMethod(methodDescriptorParser, jApiMethod);</span>
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">						if (includeMethod(jApiMethod)) {</span>
<span class="fc" id="L457">							methods.add(jApiMethod);</span>
						}
					}
				}
<span class="fc" id="L461">			}</span>
<span class="fc" id="L462">		}</span>
<span class="fc" id="L463">	}</span>

	private Optional&lt;CtMethod&gt; findMatchingMethod(CtMethod method, List&lt;CtMethod&gt; candidates) {
<span class="fc" id="L466">		Optional&lt;CtMethod&gt; found = Optional.absent();</span>
<span class="fc" id="L467">		SignatureParser methodSignatureParser = new SignatureParser();</span>
<span class="fc" id="L468">		methodSignatureParser.parse(method);</span>
<span class="fc" id="L469">		List&lt;CtMethod&gt; methodsWithSameParameters = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L470">		findMatchingMethodsWithSameParameterTypes(candidates, methodSignatureParser, methodsWithSameParameters);</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">		if (methodsWithSameParameters.size() == 1) {</span>
<span class="fc" id="L472">			found = Optional.of(methodsWithSameParameters.get(0));</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">		} else if (methodsWithSameParameters.size() &gt; 1) {</span>
<span class="fc" id="L474">			CtMethod methodWithSameReturnType = null;</span>
<span class="fc" id="L475">			SignatureParser.ParsedParameter probeReturnType = methodSignatureParser.getReturnType();</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">			for (CtMethod candidate : methodsWithSameParameters) {</span>
<span class="fc" id="L477">				SignatureParser candidateSignatureParser = new SignatureParser();</span>
<span class="fc" id="L478">				candidateSignatureParser.parse(candidate);</span>
<span class="fc" id="L479">				SignatureParser.ParsedParameter candidateReturnType = candidateSignatureParser.getReturnType();</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">				if (probeReturnType.equals(candidateReturnType)) {</span>
<span class="fc" id="L481">					methodWithSameReturnType = candidate;</span>
				}
<span class="fc" id="L483">			}</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">			if (methodWithSameReturnType != null) {</span>
<span class="fc" id="L485">				found = Optional.of(methodWithSameReturnType);</span>
			} else {
<span class="nc" id="L487">				found = Optional.of(methodsWithSameParameters.get(0));</span>
			}
		}
<span class="fc" id="L490">		return found;</span>
	}

	private void findMatchingMethodsWithSameParameterTypes(List&lt;CtMethod&gt; candidates, SignatureParser methodSignatureParser,
														   List&lt;CtMethod&gt; methodsWithSameParameters) {
<span class="fc bfc" id="L495" title="All 2 branches covered.">		for (CtMethod candidate : candidates) {</span>
<span class="fc" id="L496">			boolean parameterListsEqual = true;</span>
<span class="fc" id="L497">			List&lt;SignatureParser.ParsedParameter&gt; probeParameters = methodSignatureParser.getParameters();</span>
<span class="fc" id="L498">			SignatureParser candidateSignatureParser = new SignatureParser();</span>
<span class="fc" id="L499">			candidateSignatureParser.parse(candidate);</span>
<span class="fc" id="L500">			List&lt;SignatureParser.ParsedParameter&gt; candidateParameters = candidateSignatureParser.getParameters();</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">			if (probeParameters.size() != candidateParameters.size()) {</span>
<span class="fc" id="L502">				parameterListsEqual = false;</span>
			}
<span class="fc bfc" id="L504" title="All 2 branches covered.">			if (parameterListsEqual) {</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">				for (int i = 0; i &lt; probeParameters.size(); i++) {</span>
<span class="fc" id="L506">					SignatureParser.ParsedParameter probeParameter = probeParameters.get(i);</span>
<span class="fc" id="L507">					SignatureParser.ParsedParameter candidateParameter = candidateParameters.get(i);</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">					if (!probeParameter.equals(candidateParameter)) {</span>
<span class="fc" id="L509">						parameterListsEqual = false;</span>
<span class="fc" id="L510">						break;</span>
					}
				}
			}
<span class="fc bfc" id="L514" title="All 2 branches covered.">			if (parameterListsEqual) {</span>
<span class="fc" id="L515">				methodsWithSameParameters.add(candidate);</span>
			}
<span class="fc" id="L517">		}</span>
<span class="fc" id="L518">	}</span>

	private boolean includeMethod(JApiMethod jApiMethod) {
<span class="fc" id="L521">		return ModifierHelper.matchesModifierLevel(jApiMethod, options.getAccessModifier());</span>
	}

	private void sortConstructorsIntoLists(JApiClass jApiClass, Map&lt;String, CtConstructor&gt; oldConstructorsMap, Map&lt;String, CtConstructor&gt; newConstructorsMap) {
<span class="fc" id="L525">		SignatureParser methodDescriptorParser = new SignatureParser();</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">		for (CtConstructor ctMethod : oldConstructorsMap.values()) {</span>
<span class="fc" id="L527">			String longName = ctMethod.getLongName();</span>
<span class="fc" id="L528">			methodDescriptorParser.parse(ctMethod);</span>
<span class="fc" id="L529">			CtConstructor foundMethod = newConstructorsMap.get(longName);</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">			if (foundMethod == null) {</span>
<span class="fc" id="L531">				JApiConstructor jApiConstructor = new JApiConstructor(jApiClass, ctMethod.getName(), JApiChangeStatus.REMOVED, Optional.of(ctMethod), Optional.&lt;CtConstructor&gt;absent(), jarArchiveComparator);</span>
<span class="fc" id="L532">				addParametersToMethod(methodDescriptorParser, jApiConstructor);</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">				if (includeConstructor(jApiConstructor)) {</span>
<span class="fc" id="L534">					constructors.add(jApiConstructor);</span>
				}
<span class="fc" id="L536">			} else {</span>
<span class="fc" id="L537">				JApiConstructor jApiConstructor = new JApiConstructor(jApiClass, ctMethod.getName(), JApiChangeStatus.UNCHANGED, Optional.of(ctMethod), Optional.of(foundMethod), jarArchiveComparator);</span>
<span class="fc" id="L538">				addParametersToMethod(methodDescriptorParser, jApiConstructor);</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">				if (includeConstructor(jApiConstructor)) {</span>
<span class="fc" id="L540">					constructors.add(jApiConstructor);</span>
				}
			}
<span class="fc" id="L543">		}</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">		for (CtConstructor ctMethod : newConstructorsMap.values()) {</span>
<span class="fc" id="L545">			String longName = ctMethod.getLongName();</span>
<span class="fc" id="L546">			methodDescriptorParser.parse(ctMethod);</span>
<span class="fc" id="L547">			CtConstructor foundMethod = oldConstructorsMap.get(longName);</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">			if (foundMethod == null) {</span>
<span class="fc" id="L549">				JApiConstructor jApiConstructor = new JApiConstructor(jApiClass, ctMethod.getName(), JApiChangeStatus.NEW, Optional.&lt;CtConstructor&gt;absent(), Optional.of(ctMethod), jarArchiveComparator);</span>
<span class="fc" id="L550">				addParametersToMethod(methodDescriptorParser, jApiConstructor);</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">				if (includeConstructor(jApiConstructor)) {</span>
<span class="fc" id="L552">					constructors.add(jApiConstructor);</span>
				}
			}
<span class="fc" id="L555">		}</span>
<span class="fc" id="L556">	}</span>

	private boolean includeConstructor(JApiConstructor jApiConstructor) {
<span class="fc" id="L559">		return ModifierHelper.matchesModifierLevel(jApiConstructor, options.getAccessModifier());</span>
	}

	private void addParametersToMethod(SignatureParser methodDescriptorParser, JApiBehavior jApiBehavior) {
<span class="fc bfc" id="L563" title="All 2 branches covered.">		for (SignatureParser.ParsedParameter param : methodDescriptorParser.getParameters()) {</span>
<span class="fc" id="L564">			jApiBehavior.addParameter(new JApiParameter(param.getType(), Optional.absent()));</span>
<span class="fc" id="L565">		}</span>
<span class="fc" id="L566">		jApiBehavior.enhanceGenericTypeToParameters();</span>
<span class="fc" id="L567">	}</span>

	private Map&lt;String, List&lt;CtMethod&gt;&gt; createMethodMap(Optional&lt;CtClass&gt; ctClassOptional) {
<span class="fc" id="L570">		Map&lt;String, List&lt;CtMethod&gt;&gt; methods = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">		if (ctClassOptional.isPresent()) {</span>
<span class="fc" id="L572">			CtClass ctClass = ctClassOptional.get();</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">			for (CtMethod ctMethod : ctClass.getDeclaredMethods()) {</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">				if (options.getFilters().includeBehavior(ctMethod)) {</span>
<span class="fc" id="L575">					String name = ctMethod.getName();</span>
<span class="fc" id="L576">					List&lt;CtMethod&gt; ctMethods = methods.get(name);</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">					if (ctMethods == null) {</span>
<span class="fc" id="L578">						ctMethods = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L579">						methods.put(name, ctMethods);</span>
					}
<span class="fc" id="L581">					ctMethods.add(ctMethod);</span>
				}
			}
		}
<span class="fc" id="L585">		return methods;</span>
	}

	private Map&lt;String, CtConstructor&gt; createConstructorMap(Optional&lt;CtClass&gt; ctClass) {
<span class="fc" id="L589">		Map&lt;String, CtConstructor&gt; methods = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">		if (ctClass.isPresent()) {</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">			for (CtConstructor ctConstructor : ctClass.get().getDeclaredConstructors()) {</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">				if (options.getFilters().includeBehavior(ctConstructor)) {</span>
<span class="fc" id="L593">					methods.put(ctConstructor.getLongName(), ctConstructor);</span>
				}
			}
		}
<span class="fc" id="L597">		return methods;</span>
	}

	private JApiChangeStatus evaluateChangeStatus(JApiChangeStatus changeStatus) {
<span class="fc bfc" id="L601" title="All 2 branches covered.">		if (changeStatus == JApiChangeStatus.UNCHANGED) {</span>
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">			if (staticModifier.getChangeStatus() != JApiChangeStatus.UNCHANGED) {</span>
<span class="nc" id="L603">				changeStatus = JApiChangeStatus.MODIFIED;</span>
			}
<span class="fc bfc" id="L605" title="All 2 branches covered.">			if (finalModifier.getChangeStatus() != JApiChangeStatus.UNCHANGED) {</span>
<span class="fc" id="L606">				changeStatus = JApiChangeStatus.MODIFIED;</span>
			}
<span class="fc bfc" id="L608" title="All 2 branches covered.">			if (accessModifier.getChangeStatus() != JApiChangeStatus.UNCHANGED) {</span>
<span class="fc" id="L609">				changeStatus = JApiChangeStatus.MODIFIED;</span>
			}
<span class="fc bfc" id="L611" title="All 2 branches covered.">			if (abstractModifier.getChangeStatus() != JApiChangeStatus.UNCHANGED) {</span>
<span class="fc" id="L612">				changeStatus = JApiChangeStatus.MODIFIED;</span>
			}
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">			if (syntheticAttribute.getChangeStatus() != JApiChangeStatus.UNCHANGED) {</span>
<span class="nc" id="L615">				changeStatus = JApiChangeStatus.MODIFIED;</span>
			}
<span class="fc bfc" id="L617" title="All 2 branches covered.">			for (JApiImplementedInterface implementedInterface : interfaces) {</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">				if (implementedInterface.getChangeStatus() != JApiChangeStatus.UNCHANGED) {</span>
<span class="fc" id="L619">					changeStatus = JApiChangeStatus.MODIFIED;</span>
				}
<span class="fc" id="L621">			}</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">			if (superclass.getChangeStatus() != JApiChangeStatus.UNCHANGED) {</span>
<span class="fc" id="L623">				changeStatus = JApiChangeStatus.MODIFIED;</span>
			}
<span class="fc bfc" id="L625" title="All 2 branches covered.">			for (JApiField field : fields) {</span>
<span class="fc bfc" id="L626" title="All 4 branches covered.">				if (field.getChangeStatus() != JApiChangeStatus.UNCHANGED &amp;&amp; !isSynthetic(field)) {</span>
<span class="fc" id="L627">					changeStatus = JApiChangeStatus.MODIFIED;</span>
<span class="fc" id="L628">					changeCausedByClassElement = true;</span>
				}
<span class="fc" id="L630">			}</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">			for (JApiMethod method : methods) {</span>
<span class="fc bfc" id="L632" title="All 4 branches covered.">				if (method.getChangeStatus() != JApiChangeStatus.UNCHANGED &amp;&amp; !isSynthetic(method)) {</span>
<span class="fc" id="L633">					changeStatus = JApiChangeStatus.MODIFIED;</span>
<span class="fc" id="L634">					changeCausedByClassElement = true;</span>
				}
<span class="fc" id="L636">			}</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">			for (JApiConstructor constructor : constructors) {</span>
<span class="pc bpc" id="L638" title="1 of 4 branches missed.">				if (constructor.getChangeStatus() != JApiChangeStatus.UNCHANGED &amp;&amp; !isSynthetic(constructor)) {</span>
<span class="fc" id="L639">					changeStatus = JApiChangeStatus.MODIFIED;</span>
<span class="fc" id="L640">					changeCausedByClassElement = true;</span>
				}
<span class="fc" id="L642">			}</span>
		}
<span class="fc" id="L644">		return changeStatus;</span>
	}

	private JApiModifier&lt;StaticModifier&gt; extractStaticModifier(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L648">		return ModifierHelper.extractModifierFromClass(oldClassOptional, newClassOptional, new ModifierHelper.ExtractModifierFromClassCallback&lt;StaticModifier&gt;() {</span>
			@Override
			public StaticModifier getModifierForOld(CtClass oldClass) {
<span class="fc bfc" id="L651" title="All 2 branches covered.">				return Modifier.isStatic(oldClass.getModifiers()) ? StaticModifier.STATIC : StaticModifier.NON_STATIC;</span>
			}

			@Override
			public StaticModifier getModifierForNew(CtClass newClass) {
<span class="fc bfc" id="L656" title="All 2 branches covered.">				return Modifier.isStatic(newClass.getModifiers()) ? StaticModifier.STATIC : StaticModifier.NON_STATIC;</span>
			}
		});
	}

	private JApiModifier&lt;FinalModifier&gt; extractFinalModifier(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L662">		return ModifierHelper.extractModifierFromClass(oldClassOptional, newClassOptional, new ModifierHelper.ExtractModifierFromClassCallback&lt;FinalModifier&gt;() {</span>
			@Override
			public FinalModifier getModifierForOld(CtClass oldClass) {
<span class="fc bfc" id="L665" title="All 2 branches covered.">				return Modifier.isFinal(oldClass.getModifiers()) ? FinalModifier.FINAL : FinalModifier.NON_FINAL;</span>
			}

			@Override
			public FinalModifier getModifierForNew(CtClass newClass) {
<span class="fc bfc" id="L670" title="All 2 branches covered.">				return Modifier.isFinal(newClass.getModifiers()) ? FinalModifier.FINAL : FinalModifier.NON_FINAL;</span>
			}
		});
	}

	private JApiModifier&lt;AccessModifier&gt; extractAccessModifier(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L676">		return ModifierHelper.extractModifierFromClass(oldClassOptional, newClassOptional, new ModifierHelper.ExtractModifierFromClassCallback&lt;AccessModifier&gt;() {</span>
			@Override
			public AccessModifier getModifierForOld(CtClass oldClass) {
<span class="fc" id="L679">				return ModifierHelper.translateToModifierLevel(oldClass.getModifiers());</span>
			}

			@Override
			public AccessModifier getModifierForNew(CtClass newClass) {
<span class="fc" id="L684">				return ModifierHelper.translateToModifierLevel(newClass.getModifiers());</span>
			}
		});
	}

	private JApiModifier&lt;AbstractModifier&gt; extractAbstractModifier(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L690">		return ModifierHelper.extractModifierFromClass(oldClassOptional, newClassOptional, new ModifierHelper.ExtractModifierFromClassCallback&lt;AbstractModifier&gt;() {</span>
			@Override
			public AbstractModifier getModifierForOld(CtClass oldClass) {
<span class="fc bfc" id="L693" title="All 2 branches covered.">				return Modifier.isAbstract(oldClass.getModifiers()) ? AbstractModifier.ABSTRACT : AbstractModifier.NON_ABSTRACT;</span>
			}

			@Override
			public AbstractModifier getModifierForNew(CtClass newClass) {
<span class="fc bfc" id="L698" title="All 2 branches covered.">				return Modifier.isAbstract(newClass.getModifiers()) ? AbstractModifier.ABSTRACT : AbstractModifier.NON_ABSTRACT;</span>
			}
		});
	}

	private JApiModifier&lt;SyntheticModifier&gt; extractSyntheticModifier(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L704">		return ModifierHelper.extractModifierFromClass(oldClassOptional, newClassOptional, new ModifierHelper.ExtractModifierFromClassCallback&lt;SyntheticModifier&gt;() {</span>
			@Override
			public SyntheticModifier getModifierForOld(CtClass oldClass) {
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">				return isSynthetic(oldClass.getModifiers()) ? SyntheticModifier.SYNTHETIC : SyntheticModifier.NON_SYNTHETIC;</span>
			}

			@Override
			public SyntheticModifier getModifierForNew(CtClass newClass) {
<span class="fc bfc" id="L712" title="All 2 branches covered.">				return isSynthetic(newClass.getModifiers()) ? SyntheticModifier.SYNTHETIC : SyntheticModifier.NON_SYNTHETIC;</span>
			}
		});
	}

	@XmlAttribute
	@Override
	public JApiJavaObjectSerializationChangeStatus getJavaObjectSerializationCompatible() {
<span class="fc" id="L720">		return jApiJavaObjectSerializationChangeStatus;</span>
	}

	@XmlAttribute
	public String getJavaObjectSerializationCompatibleAsString() {
<span class="fc" id="L725">		return jApiJavaObjectSerializationChangeStatus.getDescription();</span>
	}

	@XmlElement
	@Override
	public JApiSerialVersionUid getSerialVersionUid() {
<span class="fc" id="L731">		return this.jApiSerialVersionUid;</span>
	}

	void setJavaObjectSerializationCompatible(JApiJavaObjectSerializationChangeStatus jApiJavaObjectSerializationChangeStatus) {
<span class="fc" id="L735">		this.jApiJavaObjectSerializationChangeStatus = jApiJavaObjectSerializationChangeStatus;</span>
<span class="fc" id="L736">	}</span>

	@XmlAttribute
	public JApiChangeStatus getChangeStatus() {
<span class="fc" id="L740">		return changeStatus;</span>
	}

	@XmlAttribute
	public String getFullyQualifiedName() {
<span class="fc" id="L745">		return fullyQualifiedName;</span>
	}

	@XmlTransient
	public Optional&lt;CtClass&gt; getNewClass() {
<span class="nc" id="L750">		return newClass;</span>
	}

	@XmlTransient
	public Optional&lt;CtClass&gt; getOldClass() {
<span class="nc" id="L755">		return oldClass;</span>
	}

	@XmlElementWrapper(name = &quot;modifiers&quot;)
	@XmlElement(name = &quot;modifier&quot;)
	public List&lt;? extends JApiModifier&lt;? extends Enum&lt;? extends Enum&lt;?&gt;&gt;&gt;&gt; getModifiers() {
<span class="fc" id="L761">		return Arrays.asList(this.finalModifier, this.staticModifier, this.accessModifier, this.abstractModifier, this.syntheticModifier);</span>
	}

	@XmlElement(name = &quot;superclass&quot;)
	public JApiSuperclass getSuperclass() {
<span class="fc" id="L766">		return superclass;</span>
	}

	@XmlElementWrapper(name = &quot;interfaces&quot;)
	@XmlElement(name = &quot;interface&quot;)
	public List&lt;JApiImplementedInterface&gt; getInterfaces() {
<span class="fc" id="L772">		return interfaces;</span>
	}

	@XmlElementWrapper(name = &quot;constructors&quot;)
	@XmlElement(name = &quot;constructor&quot;)
	public List&lt;JApiConstructor&gt; getConstructors() {
<span class="fc" id="L778">		return constructors;</span>
	}

	@XmlElementWrapper(name = &quot;methods&quot;)
	@XmlElement(name = &quot;method&quot;)
	public List&lt;JApiMethod&gt; getMethods() {
<span class="fc" id="L784">		return methods;</span>
	}

	@XmlElementWrapper(name = &quot;fields&quot;)
	@XmlElement(name = &quot;field&quot;)
	public List&lt;JApiField&gt; getFields() {
<span class="fc" id="L790">		return fields;</span>
	}

	@XmlElement(name = &quot;classType&quot;)
	public JApiClassType getClassType() {
<span class="fc" id="L795">		return classType;</span>
	}

	@XmlTransient
	public JApiModifier&lt;FinalModifier&gt; getFinalModifier() {
<span class="fc" id="L800">		return this.finalModifier;</span>
	}

	@XmlTransient
	public JApiModifier&lt;StaticModifier&gt; getStaticModifier() {
<span class="fc" id="L805">		return staticModifier;</span>
	}

	@XmlTransient
	public JApiModifier&lt;AccessModifier&gt; getAccessModifier() {
<span class="fc" id="L810">		return this.accessModifier;</span>
	}

	@XmlTransient
	public JApiModifier&lt;AbstractModifier&gt; getAbstractModifier() {
<span class="fc" id="L815">		return this.abstractModifier;</span>
	}

	@XmlTransient
	public JApiModifier&lt;SyntheticModifier&gt; getSyntheticModifier() {
<span class="fc" id="L820">		return this.syntheticModifier;</span>
	}

	@XmlTransient
	public JApiAttribute&lt;SyntheticAttribute&gt; getSyntheticAttribute() {
<span class="fc" id="L825">		return syntheticAttribute;</span>
	}

	@XmlElementWrapper(name = &quot;attributes&quot;)
	@XmlElement(name = &quot;attribute&quot;)
	public List&lt;JApiAttribute&lt;? extends Enum&lt;?&gt;&gt;&gt; getAttributes() {
<span class="fc" id="L831">		List&lt;JApiAttribute&lt;? extends Enum&lt;?&gt;&gt;&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L832">		list.add(this.syntheticAttribute);</span>
<span class="fc" id="L833">		return list;</span>
	}

	@Override
	@XmlAttribute
	public boolean isBinaryCompatible() {
<span class="fc" id="L839">		boolean binaryCompatible = true;</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">		for (JApiCompatibilityChange compatibilityChange : compatibilityChanges) {</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">			if (!compatibilityChange.isBinaryCompatible()) {</span>
<span class="fc" id="L842">				binaryCompatible = false;</span>
<span class="fc" id="L843">				break;</span>
			}
<span class="fc" id="L845">		}</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">		if (binaryCompatible) {</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">			for (JApiField field : fields) {</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">				if (!field.isBinaryCompatible()) {</span>
<span class="fc" id="L849">					binaryCompatible = false;</span>
<span class="fc" id="L850">					break;</span>
				}
<span class="fc" id="L852">			}</span>
		}
<span class="fc bfc" id="L854" title="All 2 branches covered.">		if (binaryCompatible) {</span>
<span class="fc bfc" id="L855" title="All 2 branches covered.">			for (JApiMethod method : methods) {</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">				if (!method.isBinaryCompatible()) {</span>
<span class="fc" id="L857">					binaryCompatible = false;</span>
<span class="fc" id="L858">					break;</span>
				}
<span class="fc" id="L860">			}</span>
		}
<span class="fc bfc" id="L862" title="All 2 branches covered.">		if (binaryCompatible) {</span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">			for (JApiConstructor constructor : constructors) {</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">				if (!constructor.isBinaryCompatible()) {</span>
<span class="fc" id="L865">					binaryCompatible = false;</span>
<span class="fc" id="L866">					break;</span>
				}
<span class="fc" id="L868">			}</span>
		}
<span class="fc bfc" id="L870" title="All 2 branches covered.">		if (binaryCompatible) {</span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">			if (!superclass.isBinaryCompatible()) {</span>
<span class="fc" id="L872">				binaryCompatible = false;</span>
			}
		}
<span class="fc bfc" id="L875" title="All 2 branches covered.">		if (binaryCompatible) {</span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">			for (JApiImplementedInterface anInterface : interfaces) {</span>
				// don't use JApiImplementedInterface.isBinaryCompatible(), since that checks the corresponding source
				// without checking if this class still provides the equivalent methods from some other source
<span class="fc bfc" id="L879" title="All 2 branches covered.">				for (JApiCompatibilityChange change : anInterface.getCompatibilityChanges()) {</span>
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">					if (!change.isBinaryCompatible()) {</span>
<span class="fc" id="L881">						binaryCompatible = false;</span>
<span class="fc" id="L882">						break;</span>
					}
<span class="nc" id="L884">				}</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">				if (!binaryCompatible) {</span>
<span class="fc" id="L886">					break;</span>
				}
<span class="fc" id="L888">			}</span>
		}
<span class="fc" id="L890">		return binaryCompatible;</span>
	}

	@Override
	@XmlAttribute
	public boolean isSourceCompatible() {
<span class="fc" id="L896">		boolean sourceCompatible = true;</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">		for (JApiCompatibilityChange compatibilityChange : compatibilityChanges) {</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">			if (!compatibilityChange.isSourceCompatible()) {</span>
<span class="fc" id="L899">				sourceCompatible = false;</span>
<span class="fc" id="L900">				break;</span>
			}
<span class="fc" id="L902">		}</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">		if (sourceCompatible) {</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">			for (JApiField field : fields) {</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">				if (!field.isSourceCompatible()) {</span>
<span class="fc" id="L906">					sourceCompatible = false;</span>
<span class="fc" id="L907">					break;</span>
				}
<span class="fc" id="L909">			}</span>
		}
<span class="fc bfc" id="L911" title="All 2 branches covered.">		if (sourceCompatible) {</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">			for (JApiMethod method : methods) {</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">				if (!method.isSourceCompatible()) {</span>
<span class="fc" id="L914">					sourceCompatible = false;</span>
<span class="fc" id="L915">					break;</span>
				}
<span class="fc" id="L917">			}</span>
		}
<span class="fc bfc" id="L919" title="All 2 branches covered.">		if (sourceCompatible) {</span>
<span class="fc bfc" id="L920" title="All 2 branches covered.">			for (JApiConstructor constructor : constructors) {</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">				if (!constructor.isSourceCompatible()) {</span>
<span class="nc" id="L922">					sourceCompatible = false;</span>
<span class="nc" id="L923">					break;</span>
				}
<span class="fc" id="L925">			}</span>
		}
<span class="fc bfc" id="L927" title="All 2 branches covered.">		if (sourceCompatible) {</span>
<span class="fc bfc" id="L928" title="All 2 branches covered.">			if (!superclass.isSourceCompatible()) {</span>
<span class="fc" id="L929">				sourceCompatible = false;</span>
			}
		}
<span class="fc bfc" id="L932" title="All 2 branches covered.">		if (sourceCompatible) {</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">			for (JApiImplementedInterface anInterface : interfaces) {</span>
				// don't use JApiImplementedInterface.isSourceCompatible(), since that checks the corresponding source
				// without checking if this class still provides the equivalent methods from some other source
<span class="fc bfc" id="L936" title="All 2 branches covered.">				for (JApiCompatibilityChange change : anInterface.getCompatibilityChanges()) {</span>
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">					if (!change.isSourceCompatible()) {</span>
<span class="fc" id="L938">						sourceCompatible = false;</span>
<span class="fc" id="L939">						break;</span>
					}
<span class="nc" id="L941">				}</span>
<span class="fc bfc" id="L942" title="All 2 branches covered.">				if (!sourceCompatible) {</span>
<span class="fc" id="L943">					break;</span>
				}
<span class="fc" id="L945">			}</span>
		}
<span class="fc" id="L947">		return sourceCompatible;</span>
	}

	@XmlElementWrapper(name = &quot;annotations&quot;)
	@XmlElement(name = &quot;annotation&quot;)
	public List&lt;JApiAnnotation&gt; getAnnotations() {
<span class="fc" id="L953">		return annotations;</span>
	}

	@XmlTransient
	public boolean isChangeCausedByClassElement() {
<span class="nc" id="L958">		return changeCausedByClassElement;</span>
	}

	@XmlElementWrapper(name = &quot;compatibilityChanges&quot;)
	@XmlElement(name = &quot;compatibilityChange&quot;)
	public List&lt;JApiCompatibilityChange&gt; getCompatibilityChanges() {
<span class="fc" id="L964">		return this.compatibilityChanges;</span>
	}

	@XmlElement(name = &quot;classFileFormatVersion&quot;)
	public JApiClassFileFormatVersion getClassFileFormatVersion() {
<span class="fc" id="L969">		return classFileFormatVersion;</span>
	}

	@XmlElementWrapper(name = &quot;genericTemplates&quot;)
	@XmlElement(name = &quot;genericTemplate&quot;)
	public List&lt;JApiGenericTemplate&gt; getGenericTemplates() {
<span class="fc" id="L975">		return genericTemplates;</span>
	}

	public String toString()
	{
<span class="fc" id="L980">		return &quot;JApiClass [fullyQualifiedName=&quot;</span>
			+ fullyQualifiedName
			+ &quot;, changeStatus=&quot;
			+ changeStatus
			+ &quot;, compatibilityChanges=&quot;
			+ compatibilityChanges
			+ &quot;]&quot;;
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>