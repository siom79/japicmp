<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JApiClass.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">japicmp</a> &gt; <a href="index.source.html" class="el_package">japicmp.model</a> &gt; <span class="el_source">JApiClass.java</span></div><h1>JApiClass.java</h1><pre class="source lang-java linenums">package japicmp.model;

import japicmp.cmp.JarArchiveComparator;
import japicmp.cmp.JarArchiveComparatorOptions;
import japicmp.exception.JApiCmpException;
import japicmp.util.Optional;
import japicmp.util.*;
import javassist.*;
import javassist.bytecode.AnnotationsAttribute;
import javassist.bytecode.ClassFile;

import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementWrapper;
import javax.xml.bind.annotation.XmlTransient;
import java.util.*;

import static japicmp.util.ModifierHelper.isSynthetic;

public class JApiClass implements JApiHasModifiers, JApiHasChangeStatus, JApiHasAccessModifier, JApiHasStaticModifier, JApiHasFinalModifier, JApiHasAbstractModifier,
	JApiCompatibility, JApiHasAnnotations, JApiJavaObjectSerializationCompatibility, JApiCanBeSynthetic, JApiHasGenericTemplates {
	private final JarArchiveComparator jarArchiveComparator;
	private final String fullyQualifiedName;
	private final JApiClassType classType;
	private final JarArchiveComparatorOptions options;
	private final Optional&lt;CtClass&gt; oldClass;
	private final Optional&lt;CtClass&gt; newClass;
	private final JApiChangeStatus changeStatus;
	private final JApiSuperclass superclass;
<span class="fc" id="L30">	private final List&lt;JApiImplementedInterface&gt; interfaces = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L31">	private final List&lt;JApiField&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L32">	private final List&lt;JApiConstructor&gt; constructors = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L33">	private final List&lt;JApiMethod&gt; methods = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L34">	private final List&lt;JApiAnnotation&gt; annotations = new ArrayList&lt;&gt;();</span>
	private final JApiModifier&lt;AccessModifier&gt; accessModifier;
	private final JApiModifier&lt;FinalModifier&gt; finalModifier;
	private final JApiModifier&lt;StaticModifier&gt; staticModifier;
	private final JApiModifier&lt;AbstractModifier&gt; abstractModifier;
	private final JApiModifier&lt;SyntheticModifier&gt; syntheticModifier;
	private final JApiAttribute&lt;SyntheticAttribute&gt; syntheticAttribute;
<span class="fc" id="L41">	private final List&lt;JApiCompatibilityChange&gt; compatibilityChanges = new ArrayList&lt;&gt;();</span>
	private final JApiSerialVersionUid jApiSerialVersionUid;
	private final JApiClassFileFormatVersion classFileFormatVersion;
<span class="fc" id="L44">	private boolean changeCausedByClassElement = false;</span>
<span class="fc" id="L45">	private JApiJavaObjectSerializationChangeStatus jApiJavaObjectSerializationChangeStatus = JApiJavaObjectSerializationChangeStatus.NOT_SERIALIZABLE;</span>
<span class="fc" id="L46">	private List&lt;JApiGenericTemplate&gt; genericTemplates = new ArrayList&lt;&gt;();</span>

	public JApiClass(JarArchiveComparator jarArchiveComparator, String fullyQualifiedName, Optional&lt;CtClass&gt; oldClass,
<span class="fc" id="L49">					 Optional&lt;CtClass&gt; newClass, JApiChangeStatus changeStatus, JApiClassType classType) {</span>
<span class="fc" id="L50">		this.jarArchiveComparator = jarArchiveComparator;</span>
<span class="fc" id="L51">		this.options = this.jarArchiveComparator.getJarArchiveComparatorOptions();</span>
<span class="fc" id="L52">		this.fullyQualifiedName = fullyQualifiedName;</span>
<span class="fc" id="L53">		this.newClass = newClass;</span>
<span class="fc" id="L54">		this.oldClass = oldClass;</span>
<span class="fc" id="L55">		this.classType = classType;</span>
<span class="fc" id="L56">		this.superclass = extractSuperclass(oldClass, newClass);</span>
<span class="fc" id="L57">		computeGenericTemplateChanges(oldClass, newClass);</span>
<span class="fc" id="L58">		computeMethodChanges(this, oldClass, newClass);</span>
<span class="fc" id="L59">		computeInterfaceChanges(this.interfaces, oldClass, newClass);</span>
<span class="fc" id="L60">		computeFieldChanges(this.fields, oldClass, newClass);</span>
<span class="fc" id="L61">		computeAnnotationChanges(this.annotations, oldClass, newClass);</span>
<span class="fc" id="L62">		this.accessModifier = extractAccessModifier(oldClass, newClass);</span>
<span class="fc" id="L63">		this.finalModifier = extractFinalModifier(oldClass, newClass);</span>
<span class="fc" id="L64">		this.staticModifier = extractStaticModifier(oldClass, newClass);</span>
<span class="fc" id="L65">		this.abstractModifier = extractAbstractModifier(oldClass, newClass);</span>
<span class="fc" id="L66">		this.syntheticModifier = extractSyntheticModifier(oldClass, newClass);</span>
<span class="fc" id="L67">		this.syntheticAttribute = extractSyntheticAttribute(oldClass, newClass);</span>
<span class="fc" id="L68">		this.jApiSerialVersionUid = JavaObjectSerializationCompatibility.extractSerialVersionUid(options, jarArchiveComparator, oldClass, newClass);</span>
<span class="fc" id="L69">		this.classFileFormatVersion = extractClassFileFormatVersion(oldClass, newClass);</span>
<span class="fc" id="L70">		this.changeStatus = evaluateChangeStatus(changeStatus);</span>
<span class="fc" id="L71">	}</span>

	private void computeGenericTemplateChanges(Optional&lt;CtClass&gt; oldClass, Optional&lt;CtClass&gt; newClass) {
<span class="fc" id="L74">		this.genericTemplates = GenericTemplateHelper.computeGenericTemplateChanges(new GenericTemplateHelper.SignatureParserCallback() {</span>
			@Override
			public boolean isOldAndNewPresent() {
<span class="fc bfc" id="L77" title="All 4 branches covered.">				return oldClass.isPresent() &amp;&amp; newClass.isPresent();</span>
			}

			@Override
			public boolean isOldPresent() {
<span class="fc" id="L82">				return oldClass.isPresent();</span>
			}

			@Override
			public boolean isNewPresent() {
<span class="fc" id="L87">				return newClass.isPresent();</span>
			}

			@Override
			public SignatureParser oldSignatureParser() {
<span class="fc" id="L92">				SignatureParser signatureParser = new SignatureParser();</span>
<span class="fc" id="L93">				signatureParser.parseTemplatesOfClass(oldClass.get());</span>
<span class="fc" id="L94">				return signatureParser;</span>
			}

			@Override
			public SignatureParser newSignatureParser() {
<span class="fc" id="L99">				SignatureParser signatureParser = new SignatureParser();</span>
<span class="fc" id="L100">				signatureParser.parseTemplatesOfClass(newClass.get());</span>
<span class="fc" id="L101">				return signatureParser;</span>
			}
		});
<span class="fc" id="L104">	}</span>

	private JApiClassFileFormatVersion extractClassFileFormatVersion(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc bfc" id="L107" title="All 4 branches covered.">		if (oldClassOptional.isPresent() &amp;&amp; newClassOptional.isPresent()) {</span>
<span class="fc" id="L108">			CtClass oldClass = oldClassOptional.get();</span>
<span class="fc" id="L109">			CtClass newClass = newClassOptional.get();</span>
<span class="fc" id="L110">			ClassFile classFileOld = oldClass.getClassFile();</span>
<span class="fc" id="L111">			ClassFile classFileNew = newClass.getClassFile();</span>
<span class="fc" id="L112">			return new JApiClassFileFormatVersion(classFileOld.getMajorVersion(), classFileOld.getMinorVersion(), classFileNew.getMajorVersion(), classFileNew.getMinorVersion());</span>
		} else {
<span class="fc bfc" id="L114" title="All 2 branches covered.">			if (oldClassOptional.isPresent()) {</span>
<span class="fc" id="L115">				CtClass oldClass = oldClassOptional.get();</span>
<span class="fc" id="L116">				ClassFile classFileOld = oldClass.getClassFile();</span>
<span class="fc" id="L117">				return new JApiClassFileFormatVersion(classFileOld.getMajorVersion(), classFileOld.getMinorVersion(), -1, -1);</span>
			}
<span class="fc bfc" id="L119" title="All 2 branches covered.">			if (newClassOptional.isPresent()) {</span>
<span class="fc" id="L120">				CtClass newClass = newClassOptional.get();</span>
<span class="fc" id="L121">				ClassFile classFileNew = newClass.getClassFile();</span>
<span class="fc" id="L122">				return new JApiClassFileFormatVersion(-1, -1, classFileNew.getMajorVersion(), classFileNew.getMinorVersion());</span>
			}
<span class="fc" id="L124">			return new JApiClassFileFormatVersion(-1, -1, -1, -1);</span>
		}
	}

	private void computeAnnotationChanges(List&lt;JApiAnnotation&gt; annotations, Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L129">		AnnotationHelper.computeAnnotationChanges(annotations, oldClassOptional, newClassOptional, options, new AnnotationHelper.AnnotationsAttributeCallback&lt;CtClass&gt;() {</span>
			@Override
			public AnnotationsAttribute getAnnotationsAttribute(CtClass ctClass) {
<span class="fc" id="L132">				return (AnnotationsAttribute) ctClass.getClassFile().getAttribute(AnnotationsAttribute.visibleTag);</span>
			}
		});
<span class="fc" id="L135">	}</span>

	private JApiAttribute&lt;SyntheticAttribute&gt; extractSyntheticAttribute(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L138">		JApiAttribute&lt;SyntheticAttribute&gt; jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.UNCHANGED, Optional.of(SyntheticAttribute.SYNTHETIC), Optional.of(SyntheticAttribute.SYNTHETIC));</span>
<span class="fc bfc" id="L139" title="All 4 branches covered.">		if (oldClassOptional.isPresent() &amp;&amp; newClassOptional.isPresent()) {</span>
<span class="fc" id="L140">			CtClass oldClass = oldClassOptional.get();</span>
<span class="fc" id="L141">			CtClass newClass = newClassOptional.get();</span>
<span class="fc" id="L142">			byte[] attributeOldClass = oldClass.getAttribute(Constants.JAVA_CONSTPOOL_ATTRIBUTE_SYNTHETIC);</span>
<span class="fc" id="L143">			byte[] attributeNewClass = newClass.getAttribute(Constants.JAVA_CONSTPOOL_ATTRIBUTE_SYNTHETIC);</span>
<span class="pc bpc" id="L144" title="3 of 4 branches missed.">			if (attributeOldClass != null &amp;&amp; attributeNewClass != null) {</span>
<span class="nc" id="L145">				jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.UNCHANGED, Optional.of(SyntheticAttribute.SYNTHETIC), Optional.of(SyntheticAttribute.SYNTHETIC));</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">			} else if (attributeOldClass != null) {</span>
<span class="nc" id="L147">				jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.MODIFIED, Optional.of(SyntheticAttribute.SYNTHETIC), Optional.of(SyntheticAttribute.NON_SYNTHETIC));</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">			} else if (attributeNewClass != null) {</span>
<span class="nc" id="L149">				jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.MODIFIED, Optional.of(SyntheticAttribute.NON_SYNTHETIC), Optional.of(SyntheticAttribute.SYNTHETIC));</span>
			} else {
<span class="fc" id="L151">				jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.UNCHANGED, Optional.of(SyntheticAttribute.NON_SYNTHETIC), Optional.of(SyntheticAttribute.NON_SYNTHETIC));</span>
			}
<span class="fc" id="L153">		} else {</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">			if (oldClassOptional.isPresent()) {</span>
<span class="fc" id="L155">				CtClass ctClass = oldClassOptional.get();</span>
<span class="fc" id="L156">				byte[] attribute = ctClass.getAttribute(Constants.JAVA_CONSTPOOL_ATTRIBUTE_SYNTHETIC);</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">				if (attribute != null) {</span>
<span class="nc" id="L158">					jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.REMOVED, Optional.of(SyntheticAttribute.SYNTHETIC), Optional.&lt;SyntheticAttribute&gt;absent());</span>
				} else {
<span class="fc" id="L160">					jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.REMOVED, Optional.of(SyntheticAttribute.NON_SYNTHETIC), Optional.&lt;SyntheticAttribute&gt;absent());</span>
				}
			}
<span class="fc bfc" id="L163" title="All 2 branches covered.">			if (newClassOptional.isPresent()) {</span>
<span class="fc" id="L164">				CtClass ctClass = newClassOptional.get();</span>
<span class="fc" id="L165">				byte[] attribute = ctClass.getAttribute(Constants.JAVA_CONSTPOOL_ATTRIBUTE_SYNTHETIC);</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">				if (attribute != null) {</span>
<span class="nc" id="L167">					jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.NEW, Optional.&lt;SyntheticAttribute&gt;absent(), Optional.of(SyntheticAttribute.SYNTHETIC));</span>
				} else {
<span class="fc" id="L169">					jApiAttribute = new JApiAttribute&lt;&gt;(JApiChangeStatus.NEW, Optional.&lt;SyntheticAttribute&gt;absent(), Optional.of(SyntheticAttribute.NON_SYNTHETIC));</span>
				}
			}
		}
<span class="fc" id="L173">		return jApiAttribute;</span>
	}

	private void computeFieldChanges(List&lt;JApiField&gt; fields, Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc bfc" id="L177" title="All 4 branches covered.">		if (oldClassOptional.isPresent() &amp;&amp; newClassOptional.isPresent()) {</span>
<span class="fc" id="L178">			CtClass oldClass = oldClassOptional.get();</span>
<span class="fc" id="L179">			CtClass newClass = newClassOptional.get();</span>
<span class="fc" id="L180">			Map&lt;String, CtField&gt; oldFieldsMap = buildFieldMap(oldClass);</span>
<span class="fc" id="L181">			Map&lt;String, CtField&gt; newFieldsMap = buildFieldMap(newClass);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">			for (CtField oldField : oldFieldsMap.values()) {</span>
<span class="fc" id="L183">				String oldFieldName = oldField.getName();</span>
<span class="fc" id="L184">				CtField newField = newFieldsMap.get(oldFieldName);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">				if (newField != null) {</span>
<span class="fc" id="L186">					JApiField jApiField = new JApiField(this, JApiChangeStatus.UNCHANGED, Optional.of(oldField), Optional.of(newField), options);</span>
<span class="fc" id="L187">					enhanceGenericTypeToField(oldField, jApiField.getOldGenericTypes());</span>
<span class="fc" id="L188">					enhanceGenericTypeToField(newField, jApiField.getNewGenericTypes());</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">					if (includeField(jApiField)) {</span>
<span class="fc" id="L190">						fields.add(jApiField);</span>
					}
<span class="fc" id="L192">				} else {</span>
<span class="fc" id="L193">					JApiField jApiField = new JApiField(this, JApiChangeStatus.REMOVED, Optional.of(oldField), Optional.&lt;CtField&gt;absent(), options);</span>
<span class="fc" id="L194">					enhanceGenericTypeToField(oldField, jApiField.getOldGenericTypes());</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">					if (includeField(jApiField)) {</span>
<span class="fc" id="L196">						fields.add(jApiField);</span>
					}
				}
<span class="fc" id="L199">			}</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">			for (CtField newField : newFieldsMap.values()) {</span>
<span class="fc" id="L201">				CtField oldField = oldFieldsMap.get(newField.getName());</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">				if (oldField == null) {</span>
<span class="fc" id="L203">					JApiField jApiField = new JApiField(this, JApiChangeStatus.NEW, Optional.&lt;CtField&gt;absent(), Optional.of(newField), options);</span>
<span class="fc" id="L204">					enhanceGenericTypeToField(newField, jApiField.getNewGenericTypes());</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">					if (includeField(jApiField)) {</span>
<span class="fc" id="L206">						fields.add(jApiField);</span>
					}
				}
<span class="fc" id="L209">			}</span>
<span class="fc" id="L210">		} else {</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">			if (oldClassOptional.isPresent()) {</span>
<span class="fc" id="L212">				Map&lt;String, CtField&gt; fieldMap = buildFieldMap(oldClassOptional.get());</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">				for (CtField field : fieldMap.values()) {</span>
<span class="nc" id="L214">					JApiField jApiField = new JApiField(this, JApiChangeStatus.REMOVED, Optional.of(field), Optional.&lt;CtField&gt;absent(), options);</span>
<span class="nc" id="L215">					enhanceGenericTypeToField(field, jApiField.getOldGenericTypes());</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">					if (includeField(jApiField)) {</span>
<span class="nc" id="L217">						fields.add(jApiField);</span>
					}
<span class="nc" id="L219">				}</span>
			}
<span class="fc bfc" id="L221" title="All 2 branches covered.">			if (newClassOptional.isPresent()) {</span>
<span class="fc" id="L222">				Map&lt;String, CtField&gt; fieldMap = buildFieldMap(newClassOptional.get());</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">				for (CtField field : fieldMap.values()) {</span>
<span class="fc" id="L224">					JApiField jApiField = new JApiField(this, JApiChangeStatus.NEW, Optional.&lt;CtField&gt;absent(), Optional.of(field), options);</span>
<span class="fc" id="L225">					enhanceGenericTypeToField(field, jApiField.getNewGenericTypes());</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">					if (includeField(jApiField)) {</span>
<span class="fc" id="L227">						fields.add(jApiField);</span>
					}
<span class="fc" id="L229">				}</span>
			}
		}
<span class="fc" id="L232">	}</span>

	private void enhanceGenericTypeToField(CtField field, List&lt;JApiGenericType&gt; genericTypes) {
<span class="fc bfc" id="L235" title="All 2 branches covered.">		if (field.getGenericSignature() != null) {</span>
<span class="fc" id="L236">			SignatureParser signatureParser = new SignatureParser();</span>
<span class="fc" id="L237">			List&lt;SignatureParser.ParsedParameter&gt; parsedParameters = signatureParser.parseTypes(field.getGenericSignature());</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">			if (!parsedParameters.isEmpty()) {</span>
<span class="fc" id="L239">				SignatureParser.ParsedParameter parsedParameter = parsedParameters.get(0);</span>
<span class="fc" id="L240">				SignatureParser.copyGenericParameters(parsedParameter, genericTypes);</span>
			}
		}
<span class="fc" id="L243">	}</span>

	private boolean includeField(JApiField jApiField) {
<span class="fc" id="L246">		return ModifierHelper.matchesModifierLevel(jApiField, options.getAccessModifier());</span>
	}

	private Map&lt;String, CtField&gt; buildFieldMap(CtClass ctClass) {
<span class="fc" id="L250">		Map&lt;String, CtField&gt; fieldMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L251">		CtField[] declaredFields = ctClass.getDeclaredFields();</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">		for (CtField field : declaredFields) {</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">			if (options.getFilters().includeField(field)) {</span>
<span class="fc" id="L254">				String name = field.getName();</span>
<span class="fc" id="L255">				fieldMap.put(name, field);</span>
			}
		}
<span class="fc" id="L258">		return fieldMap;</span>
	}

	private JApiSuperclass extractSuperclass(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L262">		JApiSuperclass retVal = new JApiSuperclass(this, Optional.&lt;CtClass&gt;absent(), Optional.&lt;CtClass&gt;absent(), JApiChangeStatus.UNCHANGED, jarArchiveComparator);</span>
<span class="fc bfc" id="L263" title="All 4 branches covered.">		if (oldClassOptional.isPresent() &amp;&amp; newClassOptional.isPresent()) {</span>
<span class="fc" id="L264">			CtClass oldClass = oldClassOptional.get();</span>
<span class="fc" id="L265">			CtClass newClass = newClassOptional.get();</span>
<span class="fc" id="L266">			Optional&lt;CtClass&gt; superclassOldOptional = getSuperclass(oldClass);</span>
<span class="fc" id="L267">			Optional&lt;CtClass&gt; superclassNewOptional = getSuperclass(newClass);</span>
<span class="pc bpc" id="L268" title="1 of 4 branches missed.">			if (superclassOldOptional.isPresent() &amp;&amp; superclassNewOptional.isPresent()) {</span>
<span class="fc" id="L269">				String nameOld = superclassOldOptional.get().getName();</span>
<span class="fc" id="L270">				String nameNew = superclassNewOptional.get().getName();</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">				retVal = new JApiSuperclass(this, superclassOldOptional, superclassNewOptional, nameOld.equals(nameNew) ? JApiChangeStatus.UNCHANGED : JApiChangeStatus.MODIFIED, jarArchiveComparator);</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">			} else if (superclassOldOptional.isPresent()) {</span>
<span class="nc" id="L273">				retVal = new JApiSuperclass(this, superclassOldOptional, superclassNewOptional, JApiChangeStatus.REMOVED, jarArchiveComparator);</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">			} else if (superclassNewOptional.isPresent()) {</span>
<span class="nc" id="L275">				retVal = new JApiSuperclass(this, superclassOldOptional, superclassNewOptional, JApiChangeStatus.NEW, jarArchiveComparator);</span>
			} else {
<span class="fc" id="L277">				retVal = new JApiSuperclass(this, superclassOldOptional, superclassNewOptional, JApiChangeStatus.UNCHANGED, jarArchiveComparator);</span>
			}
<span class="fc" id="L279">		} else {</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">			if (oldClassOptional.isPresent()) {</span>
<span class="fc" id="L281">				Optional&lt;CtClass&gt; superclassOldOptional = getSuperclass(oldClassOptional.get());</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">				if (superclassOldOptional.isPresent()) {</span>
<span class="fc" id="L283">					retVal = new JApiSuperclass(this, superclassOldOptional, Optional.&lt;CtClass&gt;absent(), JApiChangeStatus.REMOVED, jarArchiveComparator);</span>
				} else {
<span class="nc" id="L285">					retVal = new JApiSuperclass(this, Optional.&lt;CtClass&gt;absent(), Optional.&lt;CtClass&gt;absent(), JApiChangeStatus.UNCHANGED, jarArchiveComparator);</span>
				}
<span class="fc bfc" id="L287" title="All 2 branches covered.">			} else if (newClassOptional.isPresent()) {</span>
<span class="fc" id="L288">				Optional&lt;CtClass&gt; superclassNewOptional = getSuperclass(newClassOptional.get());</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">				if (superclassNewOptional.isPresent()) {</span>
<span class="fc" id="L290">					retVal = new JApiSuperclass(this, Optional.&lt;CtClass&gt;absent(), superclassNewOptional, JApiChangeStatus.NEW, jarArchiveComparator);</span>
				} else {
<span class="fc" id="L292">					retVal = new JApiSuperclass(this, Optional.&lt;CtClass&gt;absent(), Optional.&lt;CtClass&gt;absent(), JApiChangeStatus.UNCHANGED, jarArchiveComparator);</span>
				}
			}
		}
<span class="fc" id="L296">		retVal.setJApiClass(this);</span>
<span class="fc" id="L297">		return retVal;</span>
	}

	private Optional&lt;CtClass&gt; getSuperclass(CtClass ctClass) {
		try {
<span class="fc" id="L302">			CtClass superClass = ctClass.getSuperclass();</span>
<span class="fc" id="L303">			return Optional.fromNullable(superClass);</span>
<span class="fc" id="L304">		} catch (NotFoundException e) {</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">			if (options.getIgnoreMissingClasses().ignoreClass(e.getMessage())) {</span>
<span class="fc" id="L306">				return Optional.absent();</span>
			} else {
<span class="fc" id="L308">				throw JApiCmpException.forClassLoading(e, e.getMessage(), jarArchiveComparator);</span>
			}
		}
	}

	private void computeInterfaceChanges(List&lt;JApiImplementedInterface&gt; interfacesArg, Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc bfc" id="L314" title="All 4 branches covered.">		if (oldClassOptional.isPresent() &amp;&amp; newClassOptional.isPresent()) {</span>
<span class="fc" id="L315">			CtClass oldClass = oldClassOptional.get();</span>
<span class="fc" id="L316">			CtClass newClass = newClassOptional.get();</span>
<span class="fc" id="L317">			Map&lt;String, CtClass&gt; interfaceMapOldClass = buildInterfaceMap(oldClass, JarArchiveComparator.ArchiveType.OLD);</span>
<span class="fc" id="L318">			Map&lt;String, CtClass&gt; interfaceMapNewClass = buildInterfaceMap(newClass, JarArchiveComparator.ArchiveType.NEW);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">			for (CtClass oldInterface : interfaceMapOldClass.values()) {</span>
<span class="fc" id="L320">				CtClass ctClassFound = interfaceMapNewClass.get(oldInterface.getName());</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">				if (ctClassFound != null) {</span>
<span class="fc" id="L322">					JApiImplementedInterface jApiClass = new JApiImplementedInterface(oldInterface, oldInterface.getName(), JApiChangeStatus.UNCHANGED);</span>
<span class="fc" id="L323">					interfacesArg.add(jApiClass);</span>
<span class="fc" id="L324">				} else {</span>
<span class="fc" id="L325">					JApiImplementedInterface jApiClass = new JApiImplementedInterface(oldInterface, oldInterface.getName(), JApiChangeStatus.REMOVED);</span>
<span class="fc" id="L326">					interfacesArg.add(jApiClass);</span>
				}
<span class="fc" id="L328">			}</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">			for (CtClass newInterface : interfaceMapNewClass.values()) {</span>
<span class="fc" id="L330">				CtClass ctClassFound = interfaceMapOldClass.get(newInterface.getName());</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">				if (ctClassFound == null) {</span>
<span class="fc" id="L332">					JApiImplementedInterface jApiClass = new JApiImplementedInterface(newInterface, newInterface.getName(), JApiChangeStatus.NEW);</span>
<span class="fc" id="L333">					interfacesArg.add(jApiClass);</span>
				}
<span class="fc" id="L335">			}</span>
<span class="fc" id="L336">		} else {</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">			if (oldClassOptional.isPresent()) {</span>
<span class="fc" id="L338">				Map&lt;String, CtClass&gt; interfaceMap = buildInterfaceMap(oldClassOptional.get(), JarArchiveComparator.ArchiveType.OLD);</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">				for (CtClass ctClass : interfaceMap.values()) {</span>
<span class="fc" id="L340">					JApiImplementedInterface jApiClass = new JApiImplementedInterface(ctClass, ctClass.getName(), JApiChangeStatus.REMOVED);</span>
<span class="fc" id="L341">					interfacesArg.add(jApiClass);</span>
<span class="fc" id="L342">				}</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">			} else if (newClassOptional.isPresent()) {</span>
<span class="fc" id="L344">				Map&lt;String, CtClass&gt; interfaceMap = buildInterfaceMap(newClassOptional.get(), JarArchiveComparator.ArchiveType.NEW);</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">				for (CtClass ctClass : interfaceMap.values()) {</span>
<span class="fc" id="L346">					JApiImplementedInterface jApiClass = new JApiImplementedInterface(ctClass, ctClass.getName(), JApiChangeStatus.NEW);</span>
<span class="fc" id="L347">					interfacesArg.add(jApiClass);</span>
<span class="fc" id="L348">				}</span>
			}
		}
<span class="fc" id="L351">	}</span>

	private Map&lt;String, CtClass&gt; buildInterfaceMap(CtClass ctClass, JarArchiveComparator.ArchiveType archiveType) {
<span class="fc" id="L354">		Map&lt;String, CtClass&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L355">		buildInterfaceMap(ctClass, archiveType, map);</span>
<span class="fc" id="L356">		return map;</span>
	}

	private void buildInterfaceMap(CtClass ctClass, JarArchiveComparator.ArchiveType archiveType, Map&lt;String, CtClass&gt; map) {
		try {
<span class="fc" id="L361">			CtClass[] interfaces = ctClass.getInterfaces();</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">			for (CtClass ctInterface : interfaces) {</span>
<span class="fc" id="L363">				map.put(ctInterface.getName(), ctInterface);</span>
<span class="fc" id="L364">				buildInterfaceMap(archiveType, map, ctInterface);</span>
			}
<span class="fc" id="L366">			Optional&lt;CtClass&gt; superClassOptional = getSuperclass(ctClass);</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">			if (superClassOptional.isPresent()) {</span>
<span class="fc" id="L368">				buildInterfaceMap(superClassOptional.get(), archiveType, map);</span>
			}
<span class="nc" id="L370">		} catch (NotFoundException e) {</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">			if (!options.getIgnoreMissingClasses().ignoreClass(e.getMessage())) {</span>
<span class="nc" id="L372">				throw JApiCmpException.forClassLoading(e, &quot;Class not found: &quot; + e.getMessage(), jarArchiveComparator);</span>
			}
<span class="fc" id="L374">		}</span>
<span class="fc" id="L375">	}</span>

	private void buildInterfaceMap(JarArchiveComparator.ArchiveType archiveType, Map&lt;String, CtClass&gt; map, CtClass ctInterface) throws NotFoundException {
<span class="fc" id="L378">		Optional&lt;CtClass&gt; loadedInterfaceOptional = this.jarArchiveComparator.loadClass(archiveType, ctInterface.getName());</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">		if (loadedInterfaceOptional.isPresent()) {</span>
<span class="fc" id="L380">			CtClass loadedInterface = loadedInterfaceOptional.get();</span>
<span class="fc" id="L381">			CtClass[] loadedInterfaceInterfaces = loadedInterface.getInterfaces();</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">			for (CtClass additionalInterface : loadedInterfaceInterfaces) {</span>
<span class="fc" id="L383">				map.put(additionalInterface.getName(), additionalInterface);</span>
<span class="fc" id="L384">				buildInterfaceMap(archiveType, map, additionalInterface);</span>
			}
		}
<span class="fc" id="L387">	}</span>

	private void computeMethodChanges(JApiClass jApiClass, Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L390">		Map&lt;String, List&lt;CtMethod&gt;&gt; oldMethodsMap = createMethodMap(oldClassOptional);</span>
<span class="fc" id="L391">		Map&lt;String, List&lt;CtMethod&gt;&gt; newMethodsMap = createMethodMap(newClassOptional);</span>
<span class="fc" id="L392">		sortMethodsIntoLists(jApiClass, oldMethodsMap, newMethodsMap);</span>
<span class="fc" id="L393">		Map&lt;String, CtConstructor&gt; oldConstructorsMap = createConstructorMap(oldClassOptional);</span>
<span class="fc" id="L394">		Map&lt;String, CtConstructor&gt; newConstructorsMap = createConstructorMap(newClassOptional);</span>
<span class="fc" id="L395">		sortConstructorsIntoLists(jApiClass, oldConstructorsMap, newConstructorsMap);</span>
<span class="fc" id="L396">	}</span>

	private void sortMethodsIntoLists(JApiClass jApiClass, Map&lt;String, List&lt;CtMethod&gt;&gt; oldMethodsMap, Map&lt;String, List&lt;CtMethod&gt;&gt; newMethodsMap) {
<span class="fc" id="L399">		SignatureParser methodDescriptorParser = new SignatureParser();</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">		for (String methodName : oldMethodsMap.keySet()) {</span>
<span class="fc" id="L401">			List&lt;CtMethod&gt; oldMethodsWithSameName = oldMethodsMap.get(methodName);</span>
<span class="fc" id="L402">			Iterator&lt;CtMethod&gt; oldMethodsWithSameNameIterator = oldMethodsWithSameName.iterator();</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">			while (oldMethodsWithSameNameIterator.hasNext()) {</span>
<span class="fc" id="L404">				CtMethod oldMethod = oldMethodsWithSameNameIterator.next();</span>
<span class="fc" id="L405">				methodDescriptorParser.parse(oldMethod);</span>
<span class="fc" id="L406">				List&lt;CtMethod&gt; newMethodsWithSameName = newMethodsMap.get(methodName);</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">				if (newMethodsWithSameName == null) {</span>
<span class="fc" id="L408">					JApiMethod jApiMethod = new JApiMethod(jApiClass, oldMethod.getName(), JApiChangeStatus.REMOVED, Optional.of(oldMethod), Optional.&lt;CtMethod&gt;absent(), jarArchiveComparator);</span>
<span class="fc" id="L409">					addParametersToMethod(methodDescriptorParser, jApiMethod);</span>
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">					if (includeMethod(jApiMethod)) {</span>
<span class="fc" id="L411">						methods.add(jApiMethod);</span>
					}
<span class="fc" id="L413">				} else {</span>
<span class="fc" id="L414">					Optional&lt;CtMethod&gt; matchingMethodOptional = findMatchingMethod(oldMethod, newMethodsWithSameName);</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">					if (matchingMethodOptional.isPresent()) {</span>
<span class="fc" id="L416">						CtMethod matchingMethod = matchingMethodOptional.get();</span>
<span class="fc" id="L417">						JApiMethod jApiMethod = new JApiMethod(jApiClass, oldMethod.getName(), JApiChangeStatus.UNCHANGED, Optional.of(oldMethod), Optional.of(matchingMethod), jarArchiveComparator);</span>
<span class="fc" id="L418">						addParametersToMethod(methodDescriptorParser, jApiMethod);</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">						if (includeMethod(jApiMethod)) {</span>
<span class="fc" id="L420">							methods.add(jApiMethod);</span>
						}
<span class="fc" id="L422">						oldMethodsWithSameNameIterator.remove();</span>
<span class="fc" id="L423">						newMethodsWithSameName.remove(matchingMethod);</span>
<span class="fc" id="L424">					} else {</span>
<span class="fc" id="L425">						JApiMethod jApiMethod = new JApiMethod(jApiClass, oldMethod.getName(), JApiChangeStatus.REMOVED, Optional.of(oldMethod), Optional.&lt;CtMethod&gt;absent(), jarArchiveComparator);</span>
<span class="fc" id="L426">						addParametersToMethod(methodDescriptorParser, jApiMethod);</span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">						if (includeMethod(jApiMethod)) {</span>
<span class="fc" id="L428">							methods.add(jApiMethod);</span>
						}
					}
				}
<span class="fc" id="L432">			}</span>
<span class="fc" id="L433">		}</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">		for (String methodName : newMethodsMap.keySet()) {</span>
<span class="fc" id="L435">			List&lt;CtMethod&gt; ctMethods = newMethodsMap.get(methodName);</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">			for (CtMethod ctMethod : ctMethods) {</span>
<span class="fc" id="L437">				methodDescriptorParser.parse(ctMethod);</span>
<span class="fc" id="L438">				List&lt;CtMethod&gt; methodsWithSameName = oldMethodsMap.get(ctMethod.getName());</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">				if (methodsWithSameName == null) {</span>
<span class="fc" id="L440">					JApiMethod jApiMethod = new JApiMethod(jApiClass, ctMethod.getName(), JApiChangeStatus.NEW, Optional.&lt;CtMethod&gt;absent(), Optional.of(ctMethod), jarArchiveComparator);</span>
<span class="fc" id="L441">					addParametersToMethod(methodDescriptorParser, jApiMethod);</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">					if (includeMethod(jApiMethod)) {</span>
<span class="fc" id="L443">						methods.add(jApiMethod);</span>
					}
<span class="fc" id="L445">				} else {</span>
<span class="fc" id="L446">					Optional&lt;CtMethod&gt; matchingMethodOptional = findMatchingMethod(ctMethod, methodsWithSameName);</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">					if (matchingMethodOptional.isPresent()) {</span>
<span class="nc" id="L448">						CtMethod matchingMethod = matchingMethodOptional.get();</span>
<span class="nc" id="L449">						JApiMethod jApiMethod = new JApiMethod(jApiClass, ctMethod.getName(), JApiChangeStatus.UNCHANGED, Optional.of(ctMethod), Optional.of(matchingMethod), jarArchiveComparator);</span>
<span class="nc" id="L450">						addParametersToMethod(methodDescriptorParser, jApiMethod);</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">						if (includeMethod(jApiMethod)) {</span>
<span class="nc" id="L452">							methods.add(jApiMethod);</span>
						}
<span class="nc" id="L454">					} else {</span>
<span class="fc" id="L455">						JApiMethod jApiMethod = new JApiMethod(jApiClass, ctMethod.getName(), JApiChangeStatus.NEW, Optional.&lt;CtMethod&gt;absent(), Optional.of(ctMethod), jarArchiveComparator);</span>
<span class="fc" id="L456">						addParametersToMethod(methodDescriptorParser, jApiMethod);</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">						if (includeMethod(jApiMethod)) {</span>
<span class="fc" id="L458">							methods.add(jApiMethod);</span>
						}
					}
				}
<span class="fc" id="L462">			}</span>
<span class="fc" id="L463">		}</span>
<span class="fc" id="L464">	}</span>

	private Optional&lt;CtMethod&gt; findMatchingMethod(CtMethod method, List&lt;CtMethod&gt; candidates) {
<span class="fc" id="L467">		Optional&lt;CtMethod&gt; found = Optional.absent();</span>
<span class="fc" id="L468">		SignatureParser methodSignatureParser = new SignatureParser();</span>
<span class="fc" id="L469">		methodSignatureParser.parse(method);</span>
<span class="fc" id="L470">		List&lt;CtMethod&gt; methodsWithSameParameters = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L471">		findMatchingMethodsWithSameParameterTypes(candidates, methodSignatureParser, methodsWithSameParameters);</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">		if (methodsWithSameParameters.size() == 1) {</span>
<span class="fc" id="L473">			found = Optional.of(methodsWithSameParameters.get(0));</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">		} else if (methodsWithSameParameters.size() &gt; 1) {</span>
<span class="fc" id="L475">			CtMethod methodWithSameReturnType = null;</span>
<span class="fc" id="L476">			SignatureParser.ParsedParameter probeReturnType = methodSignatureParser.getReturnType();</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">			for (CtMethod candidate : methodsWithSameParameters) {</span>
<span class="fc" id="L478">				SignatureParser candidateSignatureParser = new SignatureParser();</span>
<span class="fc" id="L479">				candidateSignatureParser.parse(candidate);</span>
<span class="fc" id="L480">				SignatureParser.ParsedParameter candidateReturnType = candidateSignatureParser.getReturnType();</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">				if (probeReturnType.equals(candidateReturnType)) {</span>
<span class="fc" id="L482">					methodWithSameReturnType = candidate;</span>
				}
<span class="fc" id="L484">			}</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">			if (methodWithSameReturnType != null) {</span>
<span class="fc" id="L486">				found = Optional.of(methodWithSameReturnType);</span>
			} else {
<span class="nc" id="L488">				found = Optional.of(methodsWithSameParameters.get(0));</span>
			}
		}
<span class="fc" id="L491">		return found;</span>
	}

	private void findMatchingMethodsWithSameParameterTypes(List&lt;CtMethod&gt; candidates, SignatureParser methodSignatureParser,
														   List&lt;CtMethod&gt; methodsWithSameParameters) {
<span class="fc bfc" id="L496" title="All 2 branches covered.">		for (CtMethod candidate : candidates) {</span>
<span class="fc" id="L497">			boolean parameterListsEqual = true;</span>
<span class="fc" id="L498">			List&lt;SignatureParser.ParsedParameter&gt; probeParameters = methodSignatureParser.getParameters();</span>
<span class="fc" id="L499">			SignatureParser candidateSignatureParser = new SignatureParser();</span>
<span class="fc" id="L500">			candidateSignatureParser.parse(candidate);</span>
<span class="fc" id="L501">			List&lt;SignatureParser.ParsedParameter&gt; candidateParameters = candidateSignatureParser.getParameters();</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">			if (probeParameters.size() != candidateParameters.size()) {</span>
<span class="fc" id="L503">				parameterListsEqual = false;</span>
			}
<span class="fc bfc" id="L505" title="All 2 branches covered.">			if (parameterListsEqual) {</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">				for (int i = 0; i &lt; probeParameters.size(); i++) {</span>
<span class="fc" id="L507">					SignatureParser.ParsedParameter probeParameter = probeParameters.get(i);</span>
<span class="fc" id="L508">					SignatureParser.ParsedParameter candidateParameter = candidateParameters.get(i);</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">					if (!probeParameter.equals(candidateParameter)) {</span>
<span class="fc" id="L510">						parameterListsEqual = false;</span>
<span class="fc" id="L511">						break;</span>
					}
				}
			}
<span class="fc bfc" id="L515" title="All 2 branches covered.">			if (parameterListsEqual) {</span>
<span class="fc" id="L516">				methodsWithSameParameters.add(candidate);</span>
			}
<span class="fc" id="L518">		}</span>
<span class="fc" id="L519">	}</span>

	private boolean includeMethod(JApiMethod jApiMethod) {
<span class="fc" id="L522">		return ModifierHelper.matchesModifierLevel(jApiMethod, options.getAccessModifier());</span>
	}

	private void sortConstructorsIntoLists(JApiClass jApiClass, Map&lt;String, CtConstructor&gt; oldConstructorsMap, Map&lt;String, CtConstructor&gt; newConstructorsMap) {
<span class="fc" id="L526">		SignatureParser methodDescriptorParser = new SignatureParser();</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">		for (CtConstructor ctMethod : oldConstructorsMap.values()) {</span>
<span class="fc" id="L528">			String longName = ctMethod.getLongName();</span>
<span class="fc" id="L529">			methodDescriptorParser.parse(ctMethod);</span>
<span class="fc" id="L530">			CtConstructor foundMethod = newConstructorsMap.get(longName);</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">			if (foundMethod == null) {</span>
<span class="fc" id="L532">				JApiConstructor jApiConstructor = new JApiConstructor(jApiClass, ctMethod.getName(), JApiChangeStatus.REMOVED, Optional.of(ctMethod), Optional.&lt;CtConstructor&gt;absent(), jarArchiveComparator);</span>
<span class="fc" id="L533">				addParametersToMethod(methodDescriptorParser, jApiConstructor);</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">				if (includeConstructor(jApiConstructor)) {</span>
<span class="fc" id="L535">					constructors.add(jApiConstructor);</span>
				}
<span class="fc" id="L537">			} else {</span>
<span class="fc" id="L538">				JApiConstructor jApiConstructor = new JApiConstructor(jApiClass, ctMethod.getName(), JApiChangeStatus.UNCHANGED, Optional.of(ctMethod), Optional.of(foundMethod), jarArchiveComparator);</span>
<span class="fc" id="L539">				addParametersToMethod(methodDescriptorParser, jApiConstructor);</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">				if (includeConstructor(jApiConstructor)) {</span>
<span class="fc" id="L541">					constructors.add(jApiConstructor);</span>
				}
			}
<span class="fc" id="L544">		}</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">		for (CtConstructor ctMethod : newConstructorsMap.values()) {</span>
<span class="fc" id="L546">			String longName = ctMethod.getLongName();</span>
<span class="fc" id="L547">			methodDescriptorParser.parse(ctMethod);</span>
<span class="fc" id="L548">			CtConstructor foundMethod = oldConstructorsMap.get(longName);</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">			if (foundMethod == null) {</span>
<span class="fc" id="L550">				JApiConstructor jApiConstructor = new JApiConstructor(jApiClass, ctMethod.getName(), JApiChangeStatus.NEW, Optional.&lt;CtConstructor&gt;absent(), Optional.of(ctMethod), jarArchiveComparator);</span>
<span class="fc" id="L551">				addParametersToMethod(methodDescriptorParser, jApiConstructor);</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">				if (includeConstructor(jApiConstructor)) {</span>
<span class="fc" id="L553">					constructors.add(jApiConstructor);</span>
				}
			}
<span class="fc" id="L556">		}</span>
<span class="fc" id="L557">	}</span>

	private boolean includeConstructor(JApiConstructor jApiConstructor) {
<span class="fc" id="L560">		return ModifierHelper.matchesModifierLevel(jApiConstructor, options.getAccessModifier());</span>
	}

	private void addParametersToMethod(SignatureParser methodDescriptorParser, JApiBehavior jApiBehavior) {
<span class="fc bfc" id="L564" title="All 2 branches covered.">		for (SignatureParser.ParsedParameter param : methodDescriptorParser.getParameters()) {</span>
<span class="fc" id="L565">			jApiBehavior.addParameter(new JApiParameter(param.getType(), Optional.absent()));</span>
<span class="fc" id="L566">		}</span>
<span class="fc" id="L567">		jApiBehavior.enhanceGenericTypeToParameters();</span>
<span class="fc" id="L568">	}</span>

	private Map&lt;String, List&lt;CtMethod&gt;&gt; createMethodMap(Optional&lt;CtClass&gt; ctClassOptional) {
<span class="fc" id="L571">		Map&lt;String, List&lt;CtMethod&gt;&gt; methods = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">		if (ctClassOptional.isPresent()) {</span>
<span class="fc" id="L573">			CtClass ctClass = ctClassOptional.get();</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">			for (CtMethod ctMethod : ctClass.getDeclaredMethods()) {</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">				if (options.getFilters().includeBehavior(ctMethod)) {</span>
<span class="fc" id="L576">					String name = ctMethod.getName();</span>
<span class="fc" id="L577">					List&lt;CtMethod&gt; ctMethods = methods.get(name);</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">					if (ctMethods == null) {</span>
<span class="fc" id="L579">						ctMethods = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L580">						methods.put(name, ctMethods);</span>
					}
<span class="fc" id="L582">					ctMethods.add(ctMethod);</span>
				}
			}
		}
<span class="fc" id="L586">		return methods;</span>
	}

	private Map&lt;String, CtConstructor&gt; createConstructorMap(Optional&lt;CtClass&gt; ctClass) {
<span class="fc" id="L590">		Map&lt;String, CtConstructor&gt; methods = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">		if (ctClass.isPresent()) {</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">			for (CtConstructor ctConstructor : ctClass.get().getDeclaredConstructors()) {</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">				if (options.getFilters().includeBehavior(ctConstructor)) {</span>
<span class="fc" id="L594">					methods.put(ctConstructor.getLongName(), ctConstructor);</span>
				}
			}
		}
<span class="fc" id="L598">		return methods;</span>
	}

	private JApiChangeStatus evaluateChangeStatus(JApiChangeStatus changeStatus) {
<span class="fc bfc" id="L602" title="All 2 branches covered.">		if (changeStatus == JApiChangeStatus.UNCHANGED) {</span>
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">			if (staticModifier.getChangeStatus() != JApiChangeStatus.UNCHANGED) {</span>
<span class="nc" id="L604">				changeStatus = JApiChangeStatus.MODIFIED;</span>
			}
<span class="fc bfc" id="L606" title="All 2 branches covered.">			if (finalModifier.getChangeStatus() != JApiChangeStatus.UNCHANGED) {</span>
<span class="fc" id="L607">				changeStatus = JApiChangeStatus.MODIFIED;</span>
			}
<span class="fc bfc" id="L609" title="All 2 branches covered.">			if (accessModifier.getChangeStatus() != JApiChangeStatus.UNCHANGED) {</span>
<span class="fc" id="L610">				changeStatus = JApiChangeStatus.MODIFIED;</span>
			}
<span class="fc bfc" id="L612" title="All 2 branches covered.">			if (abstractModifier.getChangeStatus() != JApiChangeStatus.UNCHANGED) {</span>
<span class="fc" id="L613">				changeStatus = JApiChangeStatus.MODIFIED;</span>
			}
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">			if (syntheticAttribute.getChangeStatus() != JApiChangeStatus.UNCHANGED) {</span>
<span class="nc" id="L616">				changeStatus = JApiChangeStatus.MODIFIED;</span>
			}
<span class="fc bfc" id="L618" title="All 2 branches covered.">			for (JApiImplementedInterface implementedInterface : interfaces) {</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">				if (implementedInterface.getChangeStatus() != JApiChangeStatus.UNCHANGED) {</span>
<span class="fc" id="L620">					changeStatus = JApiChangeStatus.MODIFIED;</span>
				}
<span class="fc" id="L622">			}</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">			if (superclass.getChangeStatus() != JApiChangeStatus.UNCHANGED) {</span>
<span class="fc" id="L624">				changeStatus = JApiChangeStatus.MODIFIED;</span>
			}
<span class="fc bfc" id="L626" title="All 2 branches covered.">			for (JApiField field : fields) {</span>
<span class="fc bfc" id="L627" title="All 4 branches covered.">				if (field.getChangeStatus() != JApiChangeStatus.UNCHANGED &amp;&amp; !isSynthetic(field)) {</span>
<span class="fc" id="L628">					changeStatus = JApiChangeStatus.MODIFIED;</span>
<span class="fc" id="L629">					changeCausedByClassElement = true;</span>
				}
<span class="fc" id="L631">			}</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">			for (JApiMethod method : methods) {</span>
<span class="fc bfc" id="L633" title="All 4 branches covered.">				if (method.getChangeStatus() != JApiChangeStatus.UNCHANGED &amp;&amp; !isSynthetic(method)) {</span>
<span class="fc" id="L634">					changeStatus = JApiChangeStatus.MODIFIED;</span>
<span class="fc" id="L635">					changeCausedByClassElement = true;</span>
				}
<span class="fc" id="L637">			}</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">			for (JApiConstructor constructor : constructors) {</span>
<span class="pc bpc" id="L639" title="1 of 4 branches missed.">				if (constructor.getChangeStatus() != JApiChangeStatus.UNCHANGED &amp;&amp; !isSynthetic(constructor)) {</span>
<span class="fc" id="L640">					changeStatus = JApiChangeStatus.MODIFIED;</span>
<span class="fc" id="L641">					changeCausedByClassElement = true;</span>
				}
<span class="fc" id="L643">			}</span>
		}
<span class="fc" id="L645">		return changeStatus;</span>
	}

	private JApiModifier&lt;StaticModifier&gt; extractStaticModifier(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L649">		return ModifierHelper.extractModifierFromClass(oldClassOptional, newClassOptional, new ModifierHelper.ExtractModifierFromClassCallback&lt;StaticModifier&gt;() {</span>
			@Override
			public StaticModifier getModifierForOld(CtClass oldClass) {
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">				return Modifier.isStatic(oldClass.getModifiers()) ? StaticModifier.STATIC : StaticModifier.NON_STATIC;</span>
			}

			@Override
			public StaticModifier getModifierForNew(CtClass newClass) {
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">				return Modifier.isStatic(newClass.getModifiers()) ? StaticModifier.STATIC : StaticModifier.NON_STATIC;</span>
			}
		});
	}

	private JApiModifier&lt;FinalModifier&gt; extractFinalModifier(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L663">		return ModifierHelper.extractModifierFromClass(oldClassOptional, newClassOptional, new ModifierHelper.ExtractModifierFromClassCallback&lt;FinalModifier&gt;() {</span>
			@Override
			public FinalModifier getModifierForOld(CtClass oldClass) {
<span class="fc bfc" id="L666" title="All 2 branches covered.">				return Modifier.isFinal(oldClass.getModifiers()) ? FinalModifier.FINAL : FinalModifier.NON_FINAL;</span>
			}

			@Override
			public FinalModifier getModifierForNew(CtClass newClass) {
<span class="fc bfc" id="L671" title="All 2 branches covered.">				return Modifier.isFinal(newClass.getModifiers()) ? FinalModifier.FINAL : FinalModifier.NON_FINAL;</span>
			}
		});
	}

	private JApiModifier&lt;AccessModifier&gt; extractAccessModifier(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L677">		return ModifierHelper.extractModifierFromClass(oldClassOptional, newClassOptional, new ModifierHelper.ExtractModifierFromClassCallback&lt;AccessModifier&gt;() {</span>
			@Override
			public AccessModifier getModifierForOld(CtClass oldClass) {
<span class="fc" id="L680">				return ModifierHelper.translateToModifierLevel(oldClass.getModifiers());</span>
			}

			@Override
			public AccessModifier getModifierForNew(CtClass newClass) {
<span class="fc" id="L685">				return ModifierHelper.translateToModifierLevel(newClass.getModifiers());</span>
			}
		});
	}

	private JApiModifier&lt;AbstractModifier&gt; extractAbstractModifier(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L691">		return ModifierHelper.extractModifierFromClass(oldClassOptional, newClassOptional, new ModifierHelper.ExtractModifierFromClassCallback&lt;AbstractModifier&gt;() {</span>
			@Override
			public AbstractModifier getModifierForOld(CtClass oldClass) {
<span class="fc bfc" id="L694" title="All 2 branches covered.">				return Modifier.isAbstract(oldClass.getModifiers()) ? AbstractModifier.ABSTRACT : AbstractModifier.NON_ABSTRACT;</span>
			}

			@Override
			public AbstractModifier getModifierForNew(CtClass newClass) {
<span class="fc bfc" id="L699" title="All 2 branches covered.">				return Modifier.isAbstract(newClass.getModifiers()) ? AbstractModifier.ABSTRACT : AbstractModifier.NON_ABSTRACT;</span>
			}
		});
	}

	private JApiModifier&lt;SyntheticModifier&gt; extractSyntheticModifier(Optional&lt;CtClass&gt; oldClassOptional, Optional&lt;CtClass&gt; newClassOptional) {
<span class="fc" id="L705">		return ModifierHelper.extractModifierFromClass(oldClassOptional, newClassOptional, new ModifierHelper.ExtractModifierFromClassCallback&lt;SyntheticModifier&gt;() {</span>
			@Override
			public SyntheticModifier getModifierForOld(CtClass oldClass) {
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">				return isSynthetic(oldClass.getModifiers()) ? SyntheticModifier.SYNTHETIC : SyntheticModifier.NON_SYNTHETIC;</span>
			}

			@Override
			public SyntheticModifier getModifierForNew(CtClass newClass) {
<span class="fc bfc" id="L713" title="All 2 branches covered.">				return isSynthetic(newClass.getModifiers()) ? SyntheticModifier.SYNTHETIC : SyntheticModifier.NON_SYNTHETIC;</span>
			}
		});
	}

	@XmlAttribute
	@Override
	public JApiJavaObjectSerializationChangeStatus getJavaObjectSerializationCompatible() {
<span class="fc" id="L721">		return jApiJavaObjectSerializationChangeStatus;</span>
	}

	@XmlAttribute
	public String getJavaObjectSerializationCompatibleAsString() {
<span class="nc" id="L726">		return jApiJavaObjectSerializationChangeStatus.getDescription();</span>
	}

	@XmlElement
	@Override
	public JApiSerialVersionUid getSerialVersionUid() {
<span class="fc" id="L732">		return this.jApiSerialVersionUid;</span>
	}

	void setJavaObjectSerializationCompatible(JApiJavaObjectSerializationChangeStatus jApiJavaObjectSerializationChangeStatus) {
<span class="fc" id="L736">		this.jApiJavaObjectSerializationChangeStatus = jApiJavaObjectSerializationChangeStatus;</span>
<span class="fc" id="L737">	}</span>

	@XmlAttribute
	public JApiChangeStatus getChangeStatus() {
<span class="fc" id="L741">		return changeStatus;</span>
	}

	@XmlAttribute
	public String getFullyQualifiedName() {
<span class="fc" id="L746">		return fullyQualifiedName;</span>
	}

	@XmlTransient
	public Optional&lt;CtClass&gt; getNewClass() {
<span class="nc" id="L751">		return newClass;</span>
	}

	@XmlTransient
	public Optional&lt;CtClass&gt; getOldClass() {
<span class="nc" id="L756">		return oldClass;</span>
	}

	@XmlElementWrapper(name = &quot;modifiers&quot;)
	@XmlElement(name = &quot;modifier&quot;)
	public List&lt;? extends JApiModifier&lt;? extends Enum&lt;? extends Enum&lt;?&gt;&gt;&gt;&gt; getModifiers() {
<span class="nc" id="L762">		return Arrays.asList(this.finalModifier, this.staticModifier, this.accessModifier, this.abstractModifier, this.syntheticModifier);</span>
	}

	@XmlElement(name = &quot;superclass&quot;)
	public JApiSuperclass getSuperclass() {
<span class="fc" id="L767">		return superclass;</span>
	}

	@XmlElementWrapper(name = &quot;interfaces&quot;)
	@XmlElement(name = &quot;interface&quot;)
	public List&lt;JApiImplementedInterface&gt; getInterfaces() {
<span class="fc" id="L773">		return interfaces;</span>
	}

	@XmlElementWrapper(name = &quot;constructors&quot;)
	@XmlElement(name = &quot;constructor&quot;)
	public List&lt;JApiConstructor&gt; getConstructors() {
<span class="fc" id="L779">		return constructors;</span>
	}

	@XmlElementWrapper(name = &quot;methods&quot;)
	@XmlElement(name = &quot;method&quot;)
	public List&lt;JApiMethod&gt; getMethods() {
<span class="fc" id="L785">		return methods;</span>
	}

	@XmlElementWrapper(name = &quot;fields&quot;)
	@XmlElement(name = &quot;field&quot;)
	public List&lt;JApiField&gt; getFields() {
<span class="fc" id="L791">		return fields;</span>
	}

	@XmlElement(name = &quot;classType&quot;)
	public JApiClassType getClassType() {
<span class="fc" id="L796">		return classType;</span>
	}

	@XmlTransient
	public JApiModifier&lt;FinalModifier&gt; getFinalModifier() {
<span class="fc" id="L801">		return this.finalModifier;</span>
	}

	@XmlTransient
	public JApiModifier&lt;StaticModifier&gt; getStaticModifier() {
<span class="fc" id="L806">		return staticModifier;</span>
	}

	@XmlTransient
	public JApiModifier&lt;AccessModifier&gt; getAccessModifier() {
<span class="fc" id="L811">		return this.accessModifier;</span>
	}

	@XmlTransient
	public JApiModifier&lt;AbstractModifier&gt; getAbstractModifier() {
<span class="fc" id="L816">		return this.abstractModifier;</span>
	}

	@XmlTransient
	public JApiModifier&lt;SyntheticModifier&gt; getSyntheticModifier() {
<span class="fc" id="L821">		return this.syntheticModifier;</span>
	}

	@XmlTransient
	public JApiAttribute&lt;SyntheticAttribute&gt; getSyntheticAttribute() {
<span class="fc" id="L826">		return syntheticAttribute;</span>
	}

	@XmlElementWrapper(name = &quot;attributes&quot;)
	@XmlElement(name = &quot;attribute&quot;)
	public List&lt;JApiAttribute&lt;? extends Enum&lt;?&gt;&gt;&gt; getAttributes() {
<span class="nc" id="L832">		List&lt;JApiAttribute&lt;? extends Enum&lt;?&gt;&gt;&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L833">		list.add(this.syntheticAttribute);</span>
<span class="nc" id="L834">		return list;</span>
	}

	@Override
	@XmlAttribute
	public boolean isBinaryCompatible() {
<span class="fc" id="L840">		boolean binaryCompatible = true;</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">		for (JApiCompatibilityChange compatibilityChange : compatibilityChanges) {</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">			if (!compatibilityChange.isBinaryCompatible()) {</span>
<span class="fc" id="L843">				binaryCompatible = false;</span>
<span class="fc" id="L844">				break;</span>
			}
<span class="fc" id="L846">		}</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">		if (binaryCompatible) {</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">			for (JApiField field : fields) {</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">				if (!field.isBinaryCompatible()) {</span>
<span class="fc" id="L850">					binaryCompatible = false;</span>
<span class="fc" id="L851">					break;</span>
				}
<span class="fc" id="L853">			}</span>
		}
<span class="fc bfc" id="L855" title="All 2 branches covered.">		if (binaryCompatible) {</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">			for (JApiMethod method : methods) {</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">				if (!method.isBinaryCompatible()) {</span>
<span class="fc" id="L858">					binaryCompatible = false;</span>
<span class="fc" id="L859">					break;</span>
				}
<span class="fc" id="L861">			}</span>
		}
<span class="fc bfc" id="L863" title="All 2 branches covered.">		if (binaryCompatible) {</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">			for (JApiConstructor constructor : constructors) {</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">				if (!constructor.isBinaryCompatible()) {</span>
<span class="fc" id="L866">					binaryCompatible = false;</span>
<span class="fc" id="L867">					break;</span>
				}
<span class="fc" id="L869">			}</span>
		}
<span class="fc bfc" id="L871" title="All 2 branches covered.">		if (binaryCompatible) {</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">			if (!superclass.isBinaryCompatible()) {</span>
<span class="fc" id="L873">				binaryCompatible = false;</span>
			}
		}
<span class="fc bfc" id="L876" title="All 2 branches covered.">		if (binaryCompatible) {</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">			for (JApiImplementedInterface anInterface : interfaces) {</span>
				// don't use JApiImplementedInterface.isBinaryCompatible(), since that checks the corresponding source
				// without checking if this class still provides the equivalent methods from some other source
<span class="fc bfc" id="L880" title="All 2 branches covered.">				for (JApiCompatibilityChange change : anInterface.getCompatibilityChanges()) {</span>
<span class="pc bpc" id="L881" title="1 of 2 branches missed.">					if (!change.isBinaryCompatible()) {</span>
<span class="fc" id="L882">						binaryCompatible = false;</span>
<span class="fc" id="L883">						break;</span>
					}
<span class="nc" id="L885">				}</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">				if (!binaryCompatible) {</span>
<span class="fc" id="L887">					break;</span>
				}
<span class="fc" id="L889">			}</span>
		}
<span class="fc" id="L891">		return binaryCompatible;</span>
	}

	@Override
	@XmlAttribute
	public boolean isSourceCompatible() {
<span class="fc" id="L897">		boolean sourceCompatible = true;</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">		for (JApiCompatibilityChange compatibilityChange : compatibilityChanges) {</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">			if (!compatibilityChange.isSourceCompatible()) {</span>
<span class="fc" id="L900">				sourceCompatible = false;</span>
<span class="fc" id="L901">				break;</span>
			}
<span class="fc" id="L903">		}</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">		if (sourceCompatible) {</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">			for (JApiField field : fields) {</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">				if (!field.isSourceCompatible()) {</span>
<span class="fc" id="L907">					sourceCompatible = false;</span>
<span class="fc" id="L908">					break;</span>
				}
<span class="fc" id="L910">			}</span>
		}
<span class="fc bfc" id="L912" title="All 2 branches covered.">		if (sourceCompatible) {</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">			for (JApiMethod method : methods) {</span>
<span class="fc bfc" id="L914" title="All 2 branches covered.">				if (!method.isSourceCompatible()) {</span>
<span class="fc" id="L915">					sourceCompatible = false;</span>
<span class="fc" id="L916">					break;</span>
				}
<span class="fc" id="L918">			}</span>
		}
<span class="fc bfc" id="L920" title="All 2 branches covered.">		if (sourceCompatible) {</span>
<span class="fc bfc" id="L921" title="All 2 branches covered.">			for (JApiConstructor constructor : constructors) {</span>
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">				if (!constructor.isSourceCompatible()) {</span>
<span class="nc" id="L923">					sourceCompatible = false;</span>
<span class="nc" id="L924">					break;</span>
				}
<span class="fc" id="L926">			}</span>
		}
<span class="fc bfc" id="L928" title="All 2 branches covered.">		if (sourceCompatible) {</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">			if (!superclass.isSourceCompatible()) {</span>
<span class="fc" id="L930">				sourceCompatible = false;</span>
			}
		}
<span class="fc bfc" id="L933" title="All 2 branches covered.">		if (sourceCompatible) {</span>
<span class="fc bfc" id="L934" title="All 2 branches covered.">			for (JApiImplementedInterface anInterface : interfaces) {</span>
				// don't use JApiImplementedInterface.isSourceCompatible(), since that checks the corresponding source
				// without checking if this class still provides the equivalent methods from some other source
<span class="fc bfc" id="L937" title="All 2 branches covered.">				for (JApiCompatibilityChange change : anInterface.getCompatibilityChanges()) {</span>
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">					if (!change.isSourceCompatible()) {</span>
<span class="fc" id="L939">						sourceCompatible = false;</span>
<span class="fc" id="L940">						break;</span>
					}
<span class="nc" id="L942">				}</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">				if (!sourceCompatible) {</span>
<span class="fc" id="L944">					break;</span>
				}
<span class="fc" id="L946">			}</span>
		}
<span class="fc" id="L948">		return sourceCompatible;</span>
	}

	@XmlElementWrapper(name = &quot;annotations&quot;)
	@XmlElement(name = &quot;annotation&quot;)
	public List&lt;JApiAnnotation&gt; getAnnotations() {
<span class="fc" id="L954">		return annotations;</span>
	}

	@XmlTransient
	public boolean isChangeCausedByClassElement() {
<span class="nc" id="L959">		return changeCausedByClassElement;</span>
	}

	@XmlElementWrapper(name = &quot;compatibilityChanges&quot;)
	@XmlElement(name = &quot;compatibilityChange&quot;)
	public List&lt;JApiCompatibilityChange&gt; getCompatibilityChanges() {
<span class="fc" id="L965">		return this.compatibilityChanges;</span>
	}

	@XmlElement(name = &quot;classFileFormatVersion&quot;)
	public JApiClassFileFormatVersion getClassFileFormatVersion() {
<span class="fc" id="L970">		return classFileFormatVersion;</span>
	}

	@XmlElementWrapper(name = &quot;genericTemplates&quot;)
	@XmlElement(name = &quot;genericTemplate&quot;)
	public List&lt;JApiGenericTemplate&gt; getGenericTemplates() {
<span class="fc" id="L976">		return genericTemplates;</span>
	}

	public String toString()
	{
<span class="fc" id="L981">		return &quot;JApiClass [fullyQualifiedName=&quot;</span>
			+ fullyQualifiedName
			+ &quot;, changeStatus=&quot;
			+ changeStatus
			+ &quot;, compatibilityChanges=&quot;
			+ compatibilityChanges
			+ &quot;]&quot;;
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>