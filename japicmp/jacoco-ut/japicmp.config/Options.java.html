<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Options.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">japicmp</a> &gt; <a href="index.source.html" class="el_package">japicmp.config</a> &gt; <span class="el_source">Options.java</span></div><h1>Options.java</h1><pre class="source lang-java linenums">package japicmp.config;

import com.google.common.base.Joiner;
import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableList;
import japicmp.cli.CliParser;
import japicmp.cli.JApiCli;
import japicmp.cmp.JApiCmpArchive;
import japicmp.exception.JApiCmpException;
import japicmp.filter.*;
import japicmp.model.AccessModifier;
import japicmp.util.Optional;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.jar.JarFile;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;

public class Options {
<span class="fc" id="L24">	private static final Logger LOGGER = Logger.getLogger(Options.class.getName());</span>
	static final String N_A = &quot;n.a.&quot;;
<span class="fc" id="L26">	private List&lt;JApiCmpArchive&gt; oldArchives = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L27">	private List&lt;JApiCmpArchive&gt; newArchives = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L28">	private boolean outputOnlyModifications = false;</span>
<span class="fc" id="L29">	private boolean outputOnlyBinaryIncompatibleModifications = false;</span>
<span class="fc" id="L30">	private Optional&lt;String&gt; xmlOutputFile = Optional.absent();</span>
<span class="fc" id="L31">	private Optional&lt;String&gt; htmlOutputFile = Optional.absent();</span>
<span class="fc" id="L32">	private Optional&lt;AccessModifier&gt; accessModifier = Optional.of(AccessModifier.PROTECTED);</span>
<span class="fc" id="L33">	private List&lt;Filter&gt; includes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L34">	private List&lt;Filter&gt; excludes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L35">	private boolean includeSynthetic = false;</span>
<span class="fc" id="L36">	private final IgnoreMissingClasses ignoreMissingClasses = new IgnoreMissingClasses();</span>
<span class="fc" id="L37">	private Optional&lt;String&gt; htmlStylesheet = Optional.absent();</span>
<span class="fc" id="L38">	private Optional&lt;String&gt; oldClassPath = Optional.absent();</span>
<span class="fc" id="L39">	private Optional&lt;String&gt; newClassPath = Optional.absent();</span>
<span class="fc" id="L40">	private JApiCli.ClassPathMode classPathMode = JApiCli.ClassPathMode.ONE_COMMON_CLASSPATH;</span>
<span class="fc" id="L41">	private boolean noAnnotations = false;</span>
	private boolean reportOnlyFilename;
	private boolean semanticVersioning;
	private boolean errorOnBinaryIncompatibility;
	private boolean errorOnSourceIncompatibility;
<span class="fc" id="L46">	private boolean errorOnExclusionIncompatibility = true;</span>
	private boolean errorOnModifications;
	private boolean errorOnSemanticIncompatibility;
	private boolean ignoreMissingOldVersion;
	private boolean ignoreMissingNewVersion;
	private boolean helpRequested;
	private boolean errorOnSemanticIncompatibilityForMajorVersionZero;

<span class="fc" id="L54">	Options() {</span>
		// intentionally left empty
<span class="fc" id="L56">	}</span>

	public static Options newDefault() {
<span class="fc" id="L59">		return new Options();</span>
	}

	public void verify() {
<span class="fc bfc" id="L63" title="All 2 branches covered.">		if (oldArchives.isEmpty()) {</span>
<span class="fc" id="L64">			throw new JApiCmpException(JApiCmpException.Reason.CliError, &quot;Required option -o, --old is missing.&quot;);</span>
		}
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">		if (newArchives.isEmpty()) {</span>
<span class="nc" id="L67">			throw new JApiCmpException(JApiCmpException.Reason.CliError, &quot;Required option -n, --new is missing.&quot;);</span>
		}
<span class="fc bfc" id="L69" title="All 2 branches covered.">		for (JApiCmpArchive archive : getOldArchives()) {</span>
<span class="fc" id="L70">			verifyExistsCanReadAndJar(archive);</span>
<span class="fc" id="L71">		}</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">		for (JApiCmpArchive archive : getNewArchives()) {</span>
<span class="fc" id="L73">			verifyExistsCanReadAndJar(archive);</span>
<span class="fc" id="L74">		}</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">		if (getHtmlOutputFile().isPresent()) {</span>
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">			if (getHtmlStylesheet().isPresent()) {</span>
<span class="fc" id="L77">				String pathname = getHtmlStylesheet().get();</span>
<span class="fc" id="L78">				File stylesheetFile = new File(pathname);</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">				if (!stylesheetFile.exists()) {</span>
<span class="fc" id="L80">					throw JApiCmpException.cliError(&quot;HTML stylesheet '%s' does not exist.&quot;, pathname);</span>
				}
<span class="nc" id="L82">			}</span>
		} else {
<span class="fc bfc" id="L84" title="All 2 branches covered.">			if (getHtmlStylesheet().isPresent()) {</span>
<span class="fc" id="L85">				throw JApiCmpException.cliError(&quot;Define a HTML output file, if you want to apply a stylesheet.&quot;);</span>
			}
		}
<span class="pc bpc" id="L88" title="3 of 4 branches missed.">		if (getOldClassPath().isPresent() &amp;&amp; getNewClassPath().isPresent()) {</span>
<span class="nc" id="L89">			setClassPathMode(JApiCli.ClassPathMode.TWO_SEPARATE_CLASSPATHS);</span>
		} else {
<span class="pc bpc" id="L91" title="2 of 4 branches missed.">			if (getOldClassPath().isPresent() || getNewClassPath().isPresent()) {</span>
<span class="nc" id="L92">				throw JApiCmpException.cliError(&quot;Please provide both options: &quot; + CliParser.OLD_CLASSPATH + &quot; and &quot; + CliParser.NEW_CLASSPATH);</span>
			} else {
<span class="fc" id="L94">				setClassPathMode(JApiCli.ClassPathMode.ONE_COMMON_CLASSPATH);</span>
			}
		}
<span class="fc" id="L97">	}</span>

	private static void verifyExistsCanReadAndJar(JApiCmpArchive jApiCmpArchive) {
<span class="fc" id="L100">		verifyExisting(jApiCmpArchive);</span>
<span class="fc" id="L101">		verifyCanRead(jApiCmpArchive);</span>
<span class="fc" id="L102">		verifyJarArchive(jApiCmpArchive);</span>
<span class="fc" id="L103">	}</span>

	private static void verifyExisting(JApiCmpArchive jApiCmpArchive) {
<span class="fc bfc" id="L106" title="All 2 branches covered.">		if (!jApiCmpArchive.getFile().exists()) {</span>
<span class="fc" id="L107">			throw JApiCmpException.cliError(&quot;File '%s' does not exist.&quot;, jApiCmpArchive.getFile().getAbsolutePath());</span>
		}
<span class="fc" id="L109">	}</span>

	private static void verifyCanRead(JApiCmpArchive jApiCmpArchive) {
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">		if (!jApiCmpArchive.getFile().canRead()) {</span>
<span class="nc" id="L113">			throw JApiCmpException.cliError(&quot;Cannot read file '%s'.&quot;, jApiCmpArchive.getFile().getAbsolutePath());</span>
		}
<span class="fc" id="L115">	}</span>

	private static void verifyJarArchive(JApiCmpArchive jApiCmpArchive) {
<span class="fc" id="L118">		JarFile jarFile = null;</span>
		try {
<span class="fc" id="L120">			jarFile = new JarFile(jApiCmpArchive.getFile());</span>
<span class="nc" id="L121">		} catch (IOException e) {</span>
<span class="nc" id="L122">			throw JApiCmpException.cliError(&quot;File '%s' could not be opened as a jar file: %s&quot;, jApiCmpArchive.getFile().getAbsolutePath(), e.getMessage(), e);</span>
		} finally {
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">			if (jarFile != null) {</span>
				try {
<span class="fc" id="L126">					jarFile.close();</span>
<span class="nc" id="L127">				} catch (IOException e) {</span>
<span class="nc" id="L128">					LOGGER.log(Level.FINE, &quot;Failed to close file: &quot; + e.getLocalizedMessage(), e);</span>
<span class="fc" id="L129">				}</span>
			}
		}
<span class="fc" id="L132">	}</span>

	public List&lt;JApiCmpArchive&gt; getNewArchives() {
<span class="fc" id="L135">		return newArchives;</span>
	}

	public void setNewArchives(List&lt;JApiCmpArchive&gt; newArchives) {
<span class="fc" id="L139">		this.newArchives = newArchives;</span>
<span class="fc" id="L140">	}</span>

	public List&lt;JApiCmpArchive&gt; getOldArchives() {
<span class="fc" id="L143">		return oldArchives;</span>
	}

	public void setOldArchives(List&lt;JApiCmpArchive&gt; oldArchives) {
<span class="fc" id="L147">		this.oldArchives = oldArchives;</span>
<span class="fc" id="L148">	}</span>

	public boolean isOutputOnlyModifications() {
<span class="fc" id="L151">		return outputOnlyModifications;</span>
	}

	public void setOutputOnlyModifications(boolean outputOnlyModifications) {
<span class="nc" id="L155">		this.outputOnlyModifications = outputOnlyModifications;</span>
<span class="nc" id="L156">	}</span>

	public Optional&lt;String&gt; getXmlOutputFile() {
<span class="fc" id="L159">		return xmlOutputFile;</span>
	}

	public void setXmlOutputFile(Optional&lt;String&gt; xmlOutputFile) {
<span class="fc" id="L163">		this.xmlOutputFile = xmlOutputFile;</span>
<span class="fc" id="L164">	}</span>

	public void setAccessModifier(Optional&lt;AccessModifier&gt; accessModifier) {
<span class="nc" id="L167">		this.accessModifier = accessModifier;</span>
<span class="nc" id="L168">	}</span>

	public AccessModifier getAccessModifier() {
<span class="fc" id="L171">		return accessModifier.get();</span>
	}

	public void setAccessModifier(AccessModifier accessModifier) {
<span class="nc" id="L175">		this.accessModifier = Optional.of(accessModifier);</span>
<span class="nc" id="L176">	}</span>

	public List&lt;Filter&gt; getIncludes() {
<span class="fc" id="L179">		return ImmutableList.copyOf(includes);</span>
	}

	public List&lt;Filter&gt; getExcludes() {
<span class="fc" id="L183">		return ImmutableList.copyOf(excludes);</span>
	}

	public void addExcludeFromArgument(Optional&lt;String&gt; packagesExcludeArg, boolean excludeExclusively) {
<span class="fc" id="L187">		excludes = createFilterList(packagesExcludeArg, excludes, &quot;Wrong syntax for exclude option '%s': %s&quot;, excludeExclusively);</span>
<span class="fc" id="L188">	}</span>

	public void addIncludeFromArgument(Optional&lt;String&gt; packagesIncludeArg, boolean includeExclusively) {
<span class="nc" id="L191">		includes = createFilterList(packagesIncludeArg, includes, &quot;Wrong syntax for include option '%s': %s&quot;, includeExclusively);</span>
<span class="nc" id="L192">	}</span>

	public List&lt;Filter&gt; createFilterList(Optional&lt;String&gt; argumentString, List&lt;Filter&gt; filters, String errorMessage, boolean exclusive) {
<span class="fc bfc" id="L195" title="All 2 branches covered.">		for (String filterString : Splitter.on(&quot;;&quot;).trimResults().omitEmptyStrings().split(argumentString.or(&quot;&quot;))) {</span>
			try {
				// filter based on annotations
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">				if (filterString.startsWith(&quot;@&quot;)) {</span>
<span class="nc" id="L199">					filters.add(new AnnotationClassFilter(filterString));</span>
<span class="nc" id="L200">					filters.add(new AnnotationFieldFilter(filterString));</span>
<span class="nc" id="L201">					filters.add(new AnnotationBehaviorFilter(filterString));</span>
				}
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">				if (filterString.contains(&quot;#&quot;)) {</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">					if (filterString.contains(&quot;(&quot;)) {</span>
<span class="nc" id="L205">						JavadocLikeBehaviorFilter behaviorFilter = new JavadocLikeBehaviorFilter(filterString);</span>
<span class="nc" id="L206">						filters.add(behaviorFilter);</span>
<span class="nc" id="L207">					} else {</span>
<span class="nc" id="L208">						JavadocLikeFieldFilter fieldFilter = new JavadocLikeFieldFilter(filterString);</span>
<span class="nc" id="L209">						filters.add(fieldFilter);</span>
<span class="nc" id="L210">					}</span>
				} else {
<span class="fc" id="L212">					JavaDocLikeClassFilter classFilter = new JavaDocLikeClassFilter(filterString);</span>
<span class="fc" id="L213">					filters.add(classFilter);</span>
<span class="fc" id="L214">					JavadocLikePackageFilter packageFilter = new JavadocLikePackageFilter(filterString, exclusive);</span>
<span class="fc" id="L215">					filters.add(packageFilter);</span>
				}
<span class="nc" id="L217">			} catch (Exception e) {</span>
<span class="nc" id="L218">				throw new JApiCmpException(JApiCmpException.Reason.CliError, String.format(errorMessage, filterString, e.getMessage()), e);</span>
<span class="fc" id="L219">			}</span>
<span class="fc" id="L220">		}</span>
<span class="fc" id="L221">		return filters;</span>
	}

	public boolean isOutputOnlyBinaryIncompatibleModifications() {
<span class="fc" id="L225">		return outputOnlyBinaryIncompatibleModifications;</span>
	}

	public void setOutputOnlyBinaryIncompatibleModifications(boolean outputOnlyBinaryIncompatibleModifications) {
<span class="nc" id="L229">		this.outputOnlyBinaryIncompatibleModifications = outputOnlyBinaryIncompatibleModifications;</span>
<span class="nc" id="L230">	}</span>

	public Optional&lt;String&gt; getHtmlOutputFile() {
<span class="fc" id="L233">		return htmlOutputFile;</span>
	}

	public void setHtmlOutputFile(Optional&lt;String&gt; htmlOutputFile) {
<span class="fc" id="L237">		this.htmlOutputFile = htmlOutputFile;</span>
<span class="fc" id="L238">	}</span>

	public boolean isIncludeSynthetic() {
<span class="fc" id="L241">		return includeSynthetic;</span>
	}

	public void setIncludeSynthetic(boolean showSynthetic) {
<span class="fc" id="L245">		this.includeSynthetic = showSynthetic;</span>
<span class="fc" id="L246">	}</span>

	public void setIgnoreMissingClasses(boolean ignoreMissingClasses) {
<span class="fc" id="L249">		this.ignoreMissingClasses.setIgnoreAllMissingClasses(ignoreMissingClasses);</span>
<span class="fc" id="L250">	}</span>

	public Optional&lt;String&gt; getHtmlStylesheet() {
<span class="fc" id="L253">		return htmlStylesheet;</span>
	}

	public void setHtmlStylesheet(Optional&lt;String&gt; htmlStylesheet) {
<span class="fc" id="L257">		this.htmlStylesheet = htmlStylesheet;</span>
<span class="fc" id="L258">	}</span>

	public Optional&lt;String&gt; getOldClassPath() {
<span class="fc" id="L261">		return oldClassPath;</span>
	}

	public void setOldClassPath(Optional&lt;String&gt; oldClassPath) {
<span class="nc" id="L265">		this.oldClassPath = oldClassPath;</span>
<span class="nc" id="L266">	}</span>

	public Optional&lt;String&gt; getNewClassPath() {
<span class="fc" id="L269">		return newClassPath;</span>
	}

	public void setNewClassPath(Optional&lt;String&gt; newClassPath) {
<span class="nc" id="L273">		this.newClassPath = newClassPath;</span>
<span class="nc" id="L274">	}</span>

	public JApiCli.ClassPathMode getClassPathMode() {
<span class="fc" id="L277">		return classPathMode;</span>
	}

	public void setClassPathMode(JApiCli.ClassPathMode classPathMode) {
<span class="fc" id="L281">		this.classPathMode = classPathMode;</span>
<span class="fc" id="L282">	}</span>

	public boolean isNoAnnotations() {
<span class="fc" id="L285">		return noAnnotations;</span>
	}

	public void setNoAnnotations(boolean noAnnotations) {
<span class="nc" id="L289">		this.noAnnotations = noAnnotations;</span>
<span class="nc" id="L290">	}</span>

	public void addIgnoreMissingClassRegularExpression(String missingClassRegEx) {
		try {
<span class="nc" id="L294">			Pattern pattern = Pattern.compile(missingClassRegEx);</span>
<span class="nc" id="L295">			this.ignoreMissingClasses.getIgnoreMissingClassRegularExpression().add(pattern);</span>
<span class="nc" id="L296">		} catch (Exception e) {</span>
<span class="nc" id="L297">			throw new JApiCmpException(JApiCmpException.Reason.IllegalArgument, &quot;Could not compile provided regular expression: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L298">		}</span>
<span class="nc" id="L299">	}</span>

	public IgnoreMissingClasses getIgnoreMissingClasses() {
<span class="fc" id="L302">		return ignoreMissingClasses;</span>
	}

	public void setReportOnlyFilename(boolean reportOnlyFilename) {
<span class="nc" id="L306">		this.reportOnlyFilename = reportOnlyFilename;</span>
<span class="nc" id="L307">	}</span>

	public String getDifferenceDescription() {
<span class="fc" id="L310">		Joiner joiner = Joiner.on(&quot;;&quot;);</span>
<span class="fc" id="L311">		StringBuilder sb = new StringBuilder()</span>
<span class="fc" id="L312">				.append(&quot;Comparing &quot;)</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">				.append(isOutputOnlyBinaryIncompatibleModifications() ? &quot;binary&quot; :&quot;source&quot;)</span>
<span class="fc" id="L314">				.append(&quot; compatibility of &quot;);</span>
<span class="fc" id="L315">		sb.append(joiner.join(toPathList(newArchives)));</span>
<span class="fc" id="L316">		sb.append(&quot; against &quot;);</span>
<span class="fc" id="L317">		sb.append(joiner.join(toPathList(oldArchives)));</span>
<span class="fc" id="L318">		return sb.toString();</span>
	}

	private List&lt;String&gt; toPathList(List&lt;JApiCmpArchive&gt; archives) {
<span class="fc" id="L322">		List&lt;String&gt; paths = new ArrayList&lt;&gt;(archives.size());</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">		for (JApiCmpArchive archive : archives) {</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">			if (this.reportOnlyFilename) {</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">				if (archive.getFile() != null) {</span>
<span class="nc" id="L326">					paths.add(archive.getFile().getName());</span>
				} else {
<span class="nc" id="L328">					paths.add(archive.getName());</span>
				}
			} else {
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">				if (archive.getFile() != null) {</span>
<span class="fc" id="L332">					paths.add(archive.getFile().getAbsolutePath());</span>
				} else {
<span class="nc" id="L334">					paths.add(archive.getName());</span>
				}
			}
<span class="fc" id="L337">		}</span>
<span class="fc" id="L338">		return paths;</span>
	}

	private List&lt;String&gt; toVersionList(List&lt;JApiCmpArchive&gt; archives) {
<span class="fc" id="L342">		List&lt;String&gt; versions = new ArrayList&lt;&gt;(archives.size());</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">		for (JApiCmpArchive archive : archives) {</span>
<span class="nc" id="L344">			String stringVersion = archive.getVersion().getStringVersion();</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">			if (stringVersion != null) {</span>
<span class="nc" id="L346">				versions.add(stringVersion);</span>
			}
<span class="nc" id="L348">		}</span>
<span class="fc" id="L349">		return versions;</span>
	}

	public String joinOldArchives() {
<span class="fc" id="L353">        String join = Joiner.on(&quot;;&quot;).join(toPathList(oldArchives));</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">		if (join.trim().isEmpty()) {</span>
<span class="fc" id="L355">			return N_A;</span>
		}
<span class="nc" id="L357">		return join;</span>
	}

	public String joinNewArchives() {
<span class="fc" id="L361">        String join = Joiner.on(&quot;;&quot;).join(toPathList(newArchives));</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">		if (join.trim().isEmpty()) {</span>
<span class="fc" id="L363">			return N_A;</span>
		}
<span class="nc" id="L365">		return join;</span>
	}

	public String joinOldVersions() {
<span class="fc" id="L369">        String join = Joiner.on(&quot;;&quot;).join(toVersionList(oldArchives));</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">		if (join.trim().isEmpty()) {</span>
<span class="fc" id="L371">			return N_A;</span>
		}
<span class="nc" id="L373">		return join;</span>
	}

	public String joinNewVersions() {
<span class="fc" id="L377">        String join = Joiner.on(&quot;;&quot;).join(toVersionList(newArchives));</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">		if (join.trim().isEmpty()) {</span>
<span class="fc" id="L379">			return N_A;</span>
		}
<span class="nc" id="L381">		return join;</span>
	}

	public void setSemanticVersioning(boolean semanticVersioning) {
<span class="nc" id="L385">		this.semanticVersioning = semanticVersioning;</span>
<span class="nc" id="L386">	}</span>

	public boolean isSemanticVersioning() {
<span class="fc" id="L389">		return semanticVersioning;</span>
	}

	public boolean isErrorOnBinaryIncompatibility() {
<span class="fc" id="L393">		return errorOnBinaryIncompatibility;</span>
	}

	public void setErrorOnBinaryIncompatibility(boolean errorOnBinaryIncompatibility) {
<span class="fc" id="L397">		this.errorOnBinaryIncompatibility = errorOnBinaryIncompatibility;</span>
<span class="fc" id="L398">	}</span>

	public boolean isErrorOnSourceIncompatibility() {
<span class="fc" id="L401">		return errorOnSourceIncompatibility;</span>
	}

	public void setErrorOnSourceIncompatibility(boolean errorOnSourceIncompatibility) {
<span class="fc" id="L405">		this.errorOnSourceIncompatibility = errorOnSourceIncompatibility;</span>
<span class="fc" id="L406">	}</span>

	public boolean isErrorOnExclusionIncompatibility() {
<span class="fc" id="L409">		return errorOnExclusionIncompatibility;</span>
	}

	public void setErrorOnExclusionIncompatibility(boolean errorOnExclusionIncompatibility) {
<span class="fc" id="L413">		this.errorOnExclusionIncompatibility = errorOnExclusionIncompatibility;</span>
<span class="fc" id="L414">	}</span>

	public boolean isErrorOnModifications() {
<span class="fc" id="L417">		return errorOnModifications;</span>
	}

	public void setErrorOnModifications(boolean errorOnModifications) {
<span class="nc" id="L421">		this.errorOnModifications = errorOnModifications;</span>
<span class="nc" id="L422">	}</span>

	public boolean isErrorOnSemanticIncompatibility() {
<span class="fc" id="L425">		return errorOnSemanticIncompatibility;</span>
	}

	public void setErrorOnSemanticIncompatibility(boolean errorOnSemanticIncompatibility) {
<span class="fc" id="L429">		this.errorOnSemanticIncompatibility = errorOnSemanticIncompatibility;</span>
<span class="fc" id="L430">	}</span>

	public boolean isIgnoreMissingOldVersion() {
<span class="fc" id="L433">		return ignoreMissingOldVersion;</span>
	}

	public void setIgnoreMissingOldVersion(boolean ignoreMissingOldVersion) {
<span class="fc" id="L437">		this.ignoreMissingOldVersion = ignoreMissingOldVersion;</span>
<span class="fc" id="L438">	}</span>

	public boolean isIgnoreMissingNewVersion() {
<span class="fc" id="L441">		return ignoreMissingNewVersion;</span>
	}

	public void setIgnoreMissingNewVersion(boolean ignoreMissingNewVersion) {
<span class="fc" id="L445">		this.ignoreMissingNewVersion = ignoreMissingNewVersion;</span>
<span class="fc" id="L446">	}</span>

	public boolean isHelpRequested() {
<span class="fc" id="L449">		return helpRequested;</span>
	}

	public void setHelpRequested(boolean helpRequested) {
<span class="fc" id="L453">		this.helpRequested = helpRequested;</span>
<span class="fc" id="L454">	}</span>

	public boolean isErrorOnSemanticIncompatibilityForMajorVersionZero() {
<span class="nc" id="L457">		return errorOnSemanticIncompatibilityForMajorVersionZero;</span>
	}

	public void setErrorOnSemanticIncompatibilityForMajorVersionZero(boolean errorOnSemanticIncompatibilityForMajorVersionZero) {
<span class="nc" id="L461">		this.errorOnSemanticIncompatibilityForMajorVersionZero = errorOnSemanticIncompatibilityForMajorVersionZero;</span>
<span class="nc" id="L462">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>