<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Options.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">japicmp</a> &gt; <a href="index.source.html" class="el_package">japicmp.config</a> &gt; <span class="el_source">Options.java</span></div><h1>Options.java</h1><pre class="source lang-java linenums">package japicmp.config;

import com.google.common.base.Joiner;
import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableList;
import japicmp.cli.CliParser;
import japicmp.cli.JApiCli;
import japicmp.cmp.JApiCmpArchive;
import japicmp.exception.JApiCmpException;
import japicmp.filter.*;
import japicmp.model.AccessModifier;
import japicmp.util.Optional;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.jar.JarFile;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;

public class Options {
<span class="fc" id="L24">	private static final Logger LOGGER = Logger.getLogger(Options.class.getName());</span>
	static final String N_A = &quot;n.a.&quot;;
<span class="fc" id="L26">	private List&lt;JApiCmpArchive&gt; oldArchives = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L27">	private List&lt;JApiCmpArchive&gt; newArchives = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L28">	private boolean outputOnlyModifications = false;</span>
<span class="fc" id="L29">	private boolean outputOnlyBinaryIncompatibleModifications = false;</span>
<span class="fc" id="L30">	private Optional&lt;String&gt; xmlOutputFile = Optional.absent();</span>
<span class="fc" id="L31">	private Optional&lt;String&gt; htmlOutputFile = Optional.absent();</span>
<span class="fc" id="L32">	private Optional&lt;AccessModifier&gt; accessModifier = Optional.of(AccessModifier.PROTECTED);</span>
<span class="fc" id="L33">	private List&lt;Filter&gt; includes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L34">	private List&lt;Filter&gt; excludes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L35">	private boolean includeSynthetic = false;</span>
<span class="fc" id="L36">	private final IgnoreMissingClasses ignoreMissingClasses = new IgnoreMissingClasses();</span>
<span class="fc" id="L37">	private Optional&lt;String&gt; htmlStylesheet = Optional.absent();</span>
<span class="fc" id="L38">	private Optional&lt;String&gt; oldClassPath = Optional.absent();</span>
<span class="fc" id="L39">	private Optional&lt;String&gt; newClassPath = Optional.absent();</span>
<span class="fc" id="L40">	private JApiCli.ClassPathMode classPathMode = JApiCli.ClassPathMode.ONE_COMMON_CLASSPATH;</span>
<span class="fc" id="L41">	private boolean noAnnotations = false;</span>
	private boolean reportOnlyFilename;
	private boolean reportOnlySummary;
	private boolean semanticVersioning;
	private boolean errorOnBinaryIncompatibility;
	private boolean errorOnSourceIncompatibility;
<span class="fc" id="L47">	private boolean errorOnExclusionIncompatibility = true;</span>
	private boolean errorOnModifications;
	private boolean errorOnSemanticIncompatibility;
	private boolean ignoreMissingOldVersion;
	private boolean ignoreMissingNewVersion;
	private boolean helpRequested;
	private boolean errorOnSemanticIncompatibilityForMajorVersionZero;

<span class="fc" id="L55">	Options() {</span>
		// intentionally left empty
<span class="fc" id="L57">	}</span>

	public static Options newDefault() {
<span class="fc" id="L60">		return new Options();</span>
	}

	public void verify() {
<span class="fc bfc" id="L64" title="All 2 branches covered.">		if (oldArchives.isEmpty()) {</span>
<span class="fc" id="L65">			throw new JApiCmpException(JApiCmpException.Reason.CliError, &quot;Required option -o, --old is missing.&quot;);</span>
		}
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">		if (newArchives.isEmpty()) {</span>
<span class="nc" id="L68">			throw new JApiCmpException(JApiCmpException.Reason.CliError, &quot;Required option -n, --new is missing.&quot;);</span>
		}
<span class="fc bfc" id="L70" title="All 2 branches covered.">		for (JApiCmpArchive archive : getOldArchives()) {</span>
<span class="fc" id="L71">			verifyExistsCanReadAndJar(archive);</span>
<span class="fc" id="L72">		}</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">		for (JApiCmpArchive archive : getNewArchives()) {</span>
<span class="fc" id="L74">			verifyExistsCanReadAndJar(archive);</span>
<span class="fc" id="L75">		}</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">		if (getHtmlOutputFile().isPresent()) {</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">			if (getHtmlStylesheet().isPresent()) {</span>
<span class="fc" id="L78">				String pathname = getHtmlStylesheet().get();</span>
<span class="fc" id="L79">				File stylesheetFile = new File(pathname);</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">				if (!stylesheetFile.exists()) {</span>
<span class="fc" id="L81">					throw JApiCmpException.cliError(&quot;HTML stylesheet '%s' does not exist.&quot;, pathname);</span>
				}
<span class="nc" id="L83">			}</span>
		} else {
<span class="fc bfc" id="L85" title="All 2 branches covered.">			if (getHtmlStylesheet().isPresent()) {</span>
<span class="fc" id="L86">				throw JApiCmpException.cliError(&quot;Define a HTML output file, if you want to apply a stylesheet.&quot;);</span>
			}
		}
<span class="pc bpc" id="L89" title="3 of 4 branches missed.">		if (getOldClassPath().isPresent() &amp;&amp; getNewClassPath().isPresent()) {</span>
<span class="nc" id="L90">			setClassPathMode(JApiCli.ClassPathMode.TWO_SEPARATE_CLASSPATHS);</span>
		} else {
<span class="pc bpc" id="L92" title="2 of 4 branches missed.">			if (getOldClassPath().isPresent() || getNewClassPath().isPresent()) {</span>
<span class="nc" id="L93">				throw JApiCmpException.cliError(&quot;Please provide both options: &quot; + CliParser.OLD_CLASSPATH + &quot; and &quot; + CliParser.NEW_CLASSPATH);</span>
			} else {
<span class="fc" id="L95">				setClassPathMode(JApiCli.ClassPathMode.ONE_COMMON_CLASSPATH);</span>
			}
		}
<span class="fc" id="L98">	}</span>

	private static void verifyExistsCanReadAndJar(JApiCmpArchive jApiCmpArchive) {
<span class="fc" id="L101">		verifyExisting(jApiCmpArchive);</span>
<span class="fc" id="L102">		verifyCanRead(jApiCmpArchive);</span>
<span class="fc" id="L103">		verifyJarArchive(jApiCmpArchive);</span>
<span class="fc" id="L104">	}</span>

	private static void verifyExisting(JApiCmpArchive jApiCmpArchive) {
<span class="fc bfc" id="L107" title="All 2 branches covered.">		if (!jApiCmpArchive.getFile().exists()) {</span>
<span class="fc" id="L108">			throw JApiCmpException.cliError(&quot;File '%s' does not exist.&quot;, jApiCmpArchive.getFile().getAbsolutePath());</span>
		}
<span class="fc" id="L110">	}</span>

	private static void verifyCanRead(JApiCmpArchive jApiCmpArchive) {
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">		if (!jApiCmpArchive.getFile().canRead()) {</span>
<span class="nc" id="L114">			throw JApiCmpException.cliError(&quot;Cannot read file '%s'.&quot;, jApiCmpArchive.getFile().getAbsolutePath());</span>
		}
<span class="fc" id="L116">	}</span>

	private static void verifyJarArchive(JApiCmpArchive jApiCmpArchive) {
<span class="fc" id="L119">		JarFile jarFile = null;</span>
		try {
<span class="fc" id="L121">			jarFile = new JarFile(jApiCmpArchive.getFile());</span>
<span class="nc" id="L122">		} catch (IOException e) {</span>
<span class="nc" id="L123">			throw JApiCmpException.cliError(&quot;File '%s' could not be opened as a jar file: %s&quot;, jApiCmpArchive.getFile().getAbsolutePath(), e.getMessage(), e);</span>
		} finally {
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">			if (jarFile != null) {</span>
				try {
<span class="fc" id="L127">					jarFile.close();</span>
<span class="nc" id="L128">				} catch (IOException e) {</span>
<span class="nc" id="L129">					LOGGER.log(Level.FINE, &quot;Failed to close file: &quot; + e.getLocalizedMessage(), e);</span>
<span class="fc" id="L130">				}</span>
			}
		}
<span class="fc" id="L133">	}</span>

	public List&lt;JApiCmpArchive&gt; getNewArchives() {
<span class="fc" id="L136">		return newArchives;</span>
	}

	public void setNewArchives(List&lt;JApiCmpArchive&gt; newArchives) {
<span class="fc" id="L140">		this.newArchives = newArchives;</span>
<span class="fc" id="L141">	}</span>

	public List&lt;JApiCmpArchive&gt; getOldArchives() {
<span class="fc" id="L144">		return oldArchives;</span>
	}

	public void setOldArchives(List&lt;JApiCmpArchive&gt; oldArchives) {
<span class="fc" id="L148">		this.oldArchives = oldArchives;</span>
<span class="fc" id="L149">	}</span>

	public boolean isOutputOnlyModifications() {
<span class="fc" id="L152">		return outputOnlyModifications;</span>
	}

	public void setOutputOnlyModifications(boolean outputOnlyModifications) {
<span class="nc" id="L156">		this.outputOnlyModifications = outputOnlyModifications;</span>
<span class="nc" id="L157">	}</span>

	public Optional&lt;String&gt; getXmlOutputFile() {
<span class="fc" id="L160">		return xmlOutputFile;</span>
	}

	public void setXmlOutputFile(Optional&lt;String&gt; xmlOutputFile) {
<span class="fc" id="L164">		this.xmlOutputFile = xmlOutputFile;</span>
<span class="fc" id="L165">	}</span>

	public void setAccessModifier(Optional&lt;AccessModifier&gt; accessModifier) {
<span class="nc" id="L168">		this.accessModifier = accessModifier;</span>
<span class="nc" id="L169">	}</span>

	public AccessModifier getAccessModifier() {
<span class="fc" id="L172">		return accessModifier.get();</span>
	}

	public void setAccessModifier(AccessModifier accessModifier) {
<span class="nc" id="L176">		this.accessModifier = Optional.of(accessModifier);</span>
<span class="nc" id="L177">	}</span>

	public List&lt;Filter&gt; getIncludes() {
<span class="fc" id="L180">		return ImmutableList.copyOf(includes);</span>
	}

	public List&lt;Filter&gt; getExcludes() {
<span class="fc" id="L184">		return ImmutableList.copyOf(excludes);</span>
	}

	public void addExcludeFromArgument(Optional&lt;String&gt; packagesExcludeArg, boolean excludeExclusively) {
<span class="fc" id="L188">		excludes = createFilterList(packagesExcludeArg, excludes, &quot;Wrong syntax for exclude option '%s': %s&quot;, excludeExclusively);</span>
<span class="fc" id="L189">	}</span>

	public void addIncludeFromArgument(Optional&lt;String&gt; packagesIncludeArg, boolean includeExclusively) {
<span class="nc" id="L192">		includes = createFilterList(packagesIncludeArg, includes, &quot;Wrong syntax for include option '%s': %s&quot;, includeExclusively);</span>
<span class="nc" id="L193">	}</span>

	public List&lt;Filter&gt; createFilterList(Optional&lt;String&gt; argumentString, List&lt;Filter&gt; filters, String errorMessage, boolean exclusive) {
<span class="fc bfc" id="L196" title="All 2 branches covered.">		for (String filterString : Splitter.on(&quot;;&quot;).trimResults().omitEmptyStrings().split(argumentString.or(&quot;&quot;))) {</span>
			try {
				// filter based on annotations
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">				if (filterString.startsWith(&quot;@&quot;)) {</span>
<span class="nc" id="L200">					filters.add(new AnnotationClassFilter(filterString));</span>
<span class="nc" id="L201">					filters.add(new AnnotationFieldFilter(filterString));</span>
<span class="nc" id="L202">					filters.add(new AnnotationBehaviorFilter(filterString));</span>
				}
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">				if (filterString.contains(&quot;#&quot;)) {</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">					if (filterString.contains(&quot;(&quot;)) {</span>
<span class="nc" id="L206">						JavadocLikeBehaviorFilter behaviorFilter = new JavadocLikeBehaviorFilter(filterString);</span>
<span class="nc" id="L207">						filters.add(behaviorFilter);</span>
<span class="nc" id="L208">					} else {</span>
<span class="nc" id="L209">						JavadocLikeFieldFilter fieldFilter = new JavadocLikeFieldFilter(filterString);</span>
<span class="nc" id="L210">						filters.add(fieldFilter);</span>
<span class="nc" id="L211">					}</span>
				} else {
<span class="fc" id="L213">					JavaDocLikeClassFilter classFilter = new JavaDocLikeClassFilter(filterString);</span>
<span class="fc" id="L214">					filters.add(classFilter);</span>
<span class="fc" id="L215">					JavadocLikePackageFilter packageFilter = new JavadocLikePackageFilter(filterString, exclusive);</span>
<span class="fc" id="L216">					filters.add(packageFilter);</span>
				}
<span class="nc" id="L218">			} catch (Exception e) {</span>
<span class="nc" id="L219">				throw new JApiCmpException(JApiCmpException.Reason.CliError, String.format(errorMessage, filterString, e.getMessage()), e);</span>
<span class="fc" id="L220">			}</span>
<span class="fc" id="L221">		}</span>
<span class="fc" id="L222">		return filters;</span>
	}

	public boolean isOutputOnlyBinaryIncompatibleModifications() {
<span class="fc" id="L226">		return outputOnlyBinaryIncompatibleModifications;</span>
	}

	public void setOutputOnlyBinaryIncompatibleModifications(boolean outputOnlyBinaryIncompatibleModifications) {
<span class="nc" id="L230">		this.outputOnlyBinaryIncompatibleModifications = outputOnlyBinaryIncompatibleModifications;</span>
<span class="nc" id="L231">	}</span>

	public Optional&lt;String&gt; getHtmlOutputFile() {
<span class="fc" id="L234">		return htmlOutputFile;</span>
	}

	public void setHtmlOutputFile(Optional&lt;String&gt; htmlOutputFile) {
<span class="fc" id="L238">		this.htmlOutputFile = htmlOutputFile;</span>
<span class="fc" id="L239">	}</span>

	public boolean isIncludeSynthetic() {
<span class="fc" id="L242">		return includeSynthetic;</span>
	}

	public void setIncludeSynthetic(boolean showSynthetic) {
<span class="fc" id="L246">		this.includeSynthetic = showSynthetic;</span>
<span class="fc" id="L247">	}</span>

	public void setIgnoreMissingClasses(boolean ignoreMissingClasses) {
<span class="fc" id="L250">		this.ignoreMissingClasses.setIgnoreAllMissingClasses(ignoreMissingClasses);</span>
<span class="fc" id="L251">	}</span>

	public Optional&lt;String&gt; getHtmlStylesheet() {
<span class="fc" id="L254">		return htmlStylesheet;</span>
	}

	public void setHtmlStylesheet(Optional&lt;String&gt; htmlStylesheet) {
<span class="fc" id="L258">		this.htmlStylesheet = htmlStylesheet;</span>
<span class="fc" id="L259">	}</span>

	public Optional&lt;String&gt; getOldClassPath() {
<span class="fc" id="L262">		return oldClassPath;</span>
	}

	public void setOldClassPath(Optional&lt;String&gt; oldClassPath) {
<span class="nc" id="L266">		this.oldClassPath = oldClassPath;</span>
<span class="nc" id="L267">	}</span>

	public Optional&lt;String&gt; getNewClassPath() {
<span class="fc" id="L270">		return newClassPath;</span>
	}

	public void setNewClassPath(Optional&lt;String&gt; newClassPath) {
<span class="nc" id="L274">		this.newClassPath = newClassPath;</span>
<span class="nc" id="L275">	}</span>

	public JApiCli.ClassPathMode getClassPathMode() {
<span class="fc" id="L278">		return classPathMode;</span>
	}

	public void setClassPathMode(JApiCli.ClassPathMode classPathMode) {
<span class="fc" id="L282">		this.classPathMode = classPathMode;</span>
<span class="fc" id="L283">	}</span>

	public boolean isNoAnnotations() {
<span class="fc" id="L286">		return noAnnotations;</span>
	}

	public void setNoAnnotations(boolean noAnnotations) {
<span class="nc" id="L290">		this.noAnnotations = noAnnotations;</span>
<span class="nc" id="L291">	}</span>

	public void addIgnoreMissingClassRegularExpression(String missingClassRegEx) {
		try {
<span class="nc" id="L295">			Pattern pattern = Pattern.compile(missingClassRegEx);</span>
<span class="nc" id="L296">			this.ignoreMissingClasses.getIgnoreMissingClassRegularExpression().add(pattern);</span>
<span class="nc" id="L297">		} catch (Exception e) {</span>
<span class="nc" id="L298">			throw new JApiCmpException(JApiCmpException.Reason.IllegalArgument, &quot;Could not compile provided regular expression: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L299">		}</span>
<span class="nc" id="L300">	}</span>

	public IgnoreMissingClasses getIgnoreMissingClasses() {
<span class="fc" id="L303">		return ignoreMissingClasses;</span>
	}

	public void setReportOnlyFilename(boolean reportOnlyFilename) {
<span class="nc" id="L307">		this.reportOnlyFilename = reportOnlyFilename;</span>
<span class="nc" id="L308">	}</span>

	public boolean isReportOnlySummary() {
<span class="fc" id="L311">		return reportOnlySummary;</span>
	}

	public void setReportOnlySummary(boolean reportOnlySummary) {
<span class="fc" id="L315">		this.reportOnlySummary = reportOnlySummary;</span>
<span class="fc" id="L316">	}</span>

	public String getDifferenceDescription() {
<span class="fc" id="L319">		Joiner joiner = Joiner.on(&quot;;&quot;);</span>
<span class="fc" id="L320">		StringBuilder sb = new StringBuilder()</span>
<span class="fc" id="L321">				.append(&quot;Comparing &quot;)</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">				.append(isOutputOnlyBinaryIncompatibleModifications() ? &quot;binary&quot; :&quot;source&quot;)</span>
<span class="fc" id="L323">				.append(&quot; compatibility of &quot;);</span>
<span class="fc" id="L324">		sb.append(joiner.join(toPathList(newArchives)));</span>
<span class="fc" id="L325">		sb.append(&quot; against &quot;);</span>
<span class="fc" id="L326">		sb.append(joiner.join(toPathList(oldArchives)));</span>
<span class="fc" id="L327">		return sb.toString();</span>
	}

	private List&lt;String&gt; toPathList(List&lt;JApiCmpArchive&gt; archives) {
<span class="fc" id="L331">		List&lt;String&gt; paths = new ArrayList&lt;&gt;(archives.size());</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">		for (JApiCmpArchive archive : archives) {</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">			if (this.reportOnlyFilename) {</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">				if (archive.getFile() != null) {</span>
<span class="nc" id="L335">					paths.add(archive.getFile().getName());</span>
				} else {
<span class="nc" id="L337">					paths.add(archive.getName());</span>
				}
			} else {
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">				if (archive.getFile() != null) {</span>
<span class="fc" id="L341">					paths.add(archive.getFile().getAbsolutePath());</span>
				} else {
<span class="nc" id="L343">					paths.add(archive.getName());</span>
				}
			}
<span class="fc" id="L346">		}</span>
<span class="fc" id="L347">		return paths;</span>
	}

	private List&lt;String&gt; toVersionList(List&lt;JApiCmpArchive&gt; archives) {
<span class="fc" id="L351">		List&lt;String&gt; versions = new ArrayList&lt;&gt;(archives.size());</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">		for (JApiCmpArchive archive : archives) {</span>
<span class="nc" id="L353">			String stringVersion = archive.getVersion().getStringVersion();</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">			if (stringVersion != null) {</span>
<span class="nc" id="L355">				versions.add(stringVersion);</span>
			}
<span class="nc" id="L357">		}</span>
<span class="fc" id="L358">		return versions;</span>
	}

	public String joinOldArchives() {
<span class="fc" id="L362">        String join = Joiner.on(&quot;;&quot;).join(toPathList(oldArchives));</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">		if (join.trim().isEmpty()) {</span>
<span class="fc" id="L364">			return N_A;</span>
		}
<span class="nc" id="L366">		return join;</span>
	}

	public String joinNewArchives() {
<span class="fc" id="L370">        String join = Joiner.on(&quot;;&quot;).join(toPathList(newArchives));</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">		if (join.trim().isEmpty()) {</span>
<span class="fc" id="L372">			return N_A;</span>
		}
<span class="nc" id="L374">		return join;</span>
	}

	public String joinOldVersions() {
<span class="fc" id="L378">        String join = Joiner.on(&quot;;&quot;).join(toVersionList(oldArchives));</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">		if (join.trim().isEmpty()) {</span>
<span class="fc" id="L380">			return N_A;</span>
		}
<span class="nc" id="L382">		return join;</span>
	}

	public String joinNewVersions() {
<span class="fc" id="L386">        String join = Joiner.on(&quot;;&quot;).join(toVersionList(newArchives));</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">		if (join.trim().isEmpty()) {</span>
<span class="fc" id="L388">			return N_A;</span>
		}
<span class="nc" id="L390">		return join;</span>
	}

	public void setSemanticVersioning(boolean semanticVersioning) {
<span class="nc" id="L394">		this.semanticVersioning = semanticVersioning;</span>
<span class="nc" id="L395">	}</span>

	public boolean isSemanticVersioning() {
<span class="fc" id="L398">		return semanticVersioning;</span>
	}

	public boolean isErrorOnBinaryIncompatibility() {
<span class="fc" id="L402">		return errorOnBinaryIncompatibility;</span>
	}

	public void setErrorOnBinaryIncompatibility(boolean errorOnBinaryIncompatibility) {
<span class="fc" id="L406">		this.errorOnBinaryIncompatibility = errorOnBinaryIncompatibility;</span>
<span class="fc" id="L407">	}</span>

	public boolean isErrorOnSourceIncompatibility() {
<span class="fc" id="L410">		return errorOnSourceIncompatibility;</span>
	}

	public void setErrorOnSourceIncompatibility(boolean errorOnSourceIncompatibility) {
<span class="fc" id="L414">		this.errorOnSourceIncompatibility = errorOnSourceIncompatibility;</span>
<span class="fc" id="L415">	}</span>

	public boolean isErrorOnExclusionIncompatibility() {
<span class="fc" id="L418">		return errorOnExclusionIncompatibility;</span>
	}

	public void setErrorOnExclusionIncompatibility(boolean errorOnExclusionIncompatibility) {
<span class="fc" id="L422">		this.errorOnExclusionIncompatibility = errorOnExclusionIncompatibility;</span>
<span class="fc" id="L423">	}</span>

	public boolean isErrorOnModifications() {
<span class="fc" id="L426">		return errorOnModifications;</span>
	}

	public void setErrorOnModifications(boolean errorOnModifications) {
<span class="nc" id="L430">		this.errorOnModifications = errorOnModifications;</span>
<span class="nc" id="L431">	}</span>

	public boolean isErrorOnSemanticIncompatibility() {
<span class="fc" id="L434">		return errorOnSemanticIncompatibility;</span>
	}

	public void setErrorOnSemanticIncompatibility(boolean errorOnSemanticIncompatibility) {
<span class="fc" id="L438">		this.errorOnSemanticIncompatibility = errorOnSemanticIncompatibility;</span>
<span class="fc" id="L439">	}</span>

	public boolean isIgnoreMissingOldVersion() {
<span class="fc" id="L442">		return ignoreMissingOldVersion;</span>
	}

	public void setIgnoreMissingOldVersion(boolean ignoreMissingOldVersion) {
<span class="fc" id="L446">		this.ignoreMissingOldVersion = ignoreMissingOldVersion;</span>
<span class="fc" id="L447">	}</span>

	public boolean isIgnoreMissingNewVersion() {
<span class="fc" id="L450">		return ignoreMissingNewVersion;</span>
	}

	public void setIgnoreMissingNewVersion(boolean ignoreMissingNewVersion) {
<span class="fc" id="L454">		this.ignoreMissingNewVersion = ignoreMissingNewVersion;</span>
<span class="fc" id="L455">	}</span>

	public boolean isHelpRequested() {
<span class="fc" id="L458">		return helpRequested;</span>
	}

	public void setHelpRequested(boolean helpRequested) {
<span class="fc" id="L462">		this.helpRequested = helpRequested;</span>
<span class="fc" id="L463">	}</span>

	public boolean isErrorOnSemanticIncompatibilityForMajorVersionZero() {
<span class="nc" id="L466">		return errorOnSemanticIncompatibilityForMajorVersionZero;</span>
	}

	public void setErrorOnSemanticIncompatibilityForMajorVersionZero(boolean errorOnSemanticIncompatibilityForMajorVersionZero) {
<span class="nc" id="L470">		this.errorOnSemanticIncompatibilityForMajorVersionZero = errorOnSemanticIncompatibilityForMajorVersionZero;</span>
<span class="nc" id="L471">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>